<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · MLJBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MLJBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../resampling/">Resampling</a></li><li><a class="tocitem" href="../composition/">Composition</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#Machines"><span>Machines</span></a></li><li><a class="tocitem" href="#Parameter-Inspection"><span>Parameter Inspection</span></a></li><li><a class="tocitem" href="#Show"><span>Show</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/MLJBase.jl/blob/dev/docs/src/utilities.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><h2 id="Machines"><a class="docs-heading-anchor" href="#Machines">Machines</a><a id="Machines-1"></a><a class="docs-heading-anchor-permalink" href="#Machines" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Union{Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Vararg{Pair}}} where C" href="#Base.replace-Union{Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Vararg{Pair}}} where C"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace(mach::Machine, field1 =&gt; value1, field2 =&gt; value2, ...)</code></pre><p><strong>Private method.</strong></p><p>Return a shallow copy of the machine <code>mach</code> with the specified field replacements. Undefined field values are preserved. Unspecified fields have identically equal values, with the exception of <code>mach.fit_okay</code>, which is always a new instance <code>Channel{Bool}(1)</code>.</p><p>The following example returns a machine with no traces of training data (but also removes any upstream dependencies in a learning network):</p><pre><code class="language-julia hljs">replace(mach, :args =&gt; (), :data =&gt; (), :data_resampled_data =&gt; (), :cache =&gt; nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL108-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.age-Tuple{Machine}" href="#MLJBase.age-Tuple{Machine}"><code>MLJBase.age</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">age(mach::Machine)</code></pre><p>Return an integer representing the number of times <code>mach</code> has been trained or updated. For more detail, see the discussion of training logic at <a href="#MLJBase.fit_only!-Union{Tuple{Machine{&lt;:Any, &lt;:Any, cache_data}}, Tuple{cache_data}} where cache_data"><code>fit_only!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.ancestors-Tuple{Machine}" href="#MLJBase.ancestors-Tuple{Machine}"><code>MLJBase.ancestors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ancestors(mach::Machine; self=false)</code></pre><p>All ancestors of <code>mach</code>, including <code>mach</code> if <code>self=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.default_scitype_check_level" href="#MLJBase.default_scitype_check_level"><code>MLJBase.default_scitype_check_level</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_scitype_check_level()</code></pre><p>Return the current global default value for scientific type checking when constructing machines.</p><pre><code class="language-julia hljs">default_scitype_check_level(i::Integer)</code></pre><p>Set the global default value for scientific type checking to <code>i</code>.</p><p>The effect of the <code>scitype_check_level</code> option in calls of the form <code>machine(model, data, scitype_check_level=...)</code> is summarized below:</p><table><tr><th style="text-align: left"><code>scitype_check_level</code></th><th style="text-align: center">Inspect scitypes?</th><th style="text-align: center">If <code>Unknown</code> in scitypes</th><th style="text-align: center">If other scitype mismatch</th></tr><tr><td style="text-align: left">0</td><td style="text-align: center">×</td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: left">1 (value at startup)</td><td style="text-align: center">✓</td><td style="text-align: center"></td><td style="text-align: center">warning</td></tr><tr><td style="text-align: left">2</td><td style="text-align: center">✓</td><td style="text-align: center">warning</td><td style="text-align: center">warning</td></tr><tr><td style="text-align: left">3</td><td style="text-align: center">✓</td><td style="text-align: center">warning</td><td style="text-align: center">error</td></tr><tr><td style="text-align: left">4</td><td style="text-align: center">✓</td><td style="text-align: center">error</td><td style="text-align: center">error</td></tr></table><p>See also <a href="#MLJBase.machine"><code>machine</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.fit_only!-Union{Tuple{Machine{&lt;:Any, &lt;:Any, cache_data}}, Tuple{cache_data}} where cache_data" href="#MLJBase.fit_only!-Union{Tuple{Machine{&lt;:Any, &lt;:Any, cache_data}}, Tuple{cache_data}} where cache_data"><code>MLJBase.fit_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MLJBase.fit_only!(
    mach::Machine;
    rows=nothing,
    verbosity=1,
    force=false,
    composite=nothing,
)</code></pre><p>Without mutating any other machine on which it may depend, perform one of the following actions to the machine <code>mach</code>, using the data and model bound to it, and restricting the data to <code>rows</code> if specified:</p><ul><li><p><em>Ab initio training.</em> Ignoring any previous learned parameters and cache, compute and store new learned parameters. Increment <code>mach.state</code>.</p></li><li><p><em>Training update.</em> Making use of previous learned parameters and/or  cache, replace or mutate existing learned parameters. The effect is  the same (or nearly the same) as in ab initio training, but may be  faster or use less memory, assuming the model supports an update  option (implements <code>MLJBase.update</code>). Increment <code>mach.state</code>.</p></li><li><p><em>No-operation.</em> Leave existing learned parameters untouched. Do not  increment <code>mach.state</code>.</p></li></ul><p>If the model, <code>model</code>, bound to <code>mach</code> is a symbol, then instead perform the action using the true model given by <code>getproperty(composite, model)</code>. See also <a href="#MLJBase.machine"><code>machine</code></a>.</p><p><strong>Training action logic</strong></p><p>For the action to be a no-operation, either <code>mach.frozen == true</code> or or none of the following apply:</p><ol><li><p><code>mach</code> has never been trained (<code>mach.state == 0</code>).</p></li><li><p><code>force == true</code>.</p></li><li><p>The <code>state</code> of some other machine on which <code>mach</code> depends has changed since the last time <code>mach</code> was trained (ie, the last time <code>mach.state</code> was last incremented).</p></li><li><p>The specified <code>rows</code> have changed since the last retraining and <code>mach.model</code> does not have <code>Static</code> type.</p></li><li><p><code>mach.model</code> is a <code>Model</code> (i.e, not a symbol) and is different from the last model used for training (but has the same type).</p></li><li><p><code>mach.model</code> is a <code>Model</code> but has a type different from the last model used for training.</p></li><li><p><code>mach.model</code> is a symbol and <code>getproperty(composite, mach.model)</code> is different from the last model used for training (but has the same type).</p></li><li><p><code>mach.model</code> is a symbol and <code>getproperty(composite, mach.model)</code> has a different type from the last model used for training.</p></li></ol><p>In any of the cases (1) - (4), (6), or (8), <code>mach</code> is trained ab initio. If (5) or (7) is true, then a training update is applied.</p><p>To freeze or unfreeze <code>mach</code>, use <code>freeze!(mach)</code> or <code>thaw!(mach)</code>.</p><p><strong>Implementation details</strong></p><p>The data to which a machine is bound is stored in <code>mach.args</code>. Each element of <code>args</code> is either a <code>Node</code> object, or, in the case that concrete data was bound to the machine, it is concrete data wrapped in a <code>Source</code> node. In all cases, to obtain concrete data for actual training, each argument <code>N</code> is called, as in <code>N()</code> or <code>N(rows=rows)</code>, and either <code>MLJBase.fit</code> (ab initio training) or <code>MLJBase.update</code> (training update) is dispatched on <code>mach.model</code> and this data. See the &quot;Adding models for general use&quot; section of the MLJ documentation for more on these lower-level training methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL541-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.freeze!-Tuple{Machine}" href="#MLJBase.freeze!-Tuple{Machine}"><code>MLJBase.freeze!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freeze!(mach)</code></pre><p>Freeze the machine <code>mach</code> so that it will never be retrained (unless thawed).</p><p>See also <a href="#MLJBase.thaw!-Tuple{Machine}"><code>thaw!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL415-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.last_model-Tuple{Any}" href="#MLJBase.last_model-Tuple{Any}"><code>MLJBase.last_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last_model(mach::Machine)</code></pre><p>Return the last model used to train the machine <code>mach</code>. This is a bona fide model, even if <code>mach.model</code> is a symbol.</p><p>Returns <code>nothing</code> if <code>mach</code> has not been trained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL531-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.machine" href="#MLJBase.machine"><code>MLJBase.machine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">machine(model, args...; cache=true, scitype_check_level=1)</code></pre><p>Construct a <code>Machine</code> object binding a <code>model</code>, storing hyper-parameters of some machine learning algorithm, to some data, <code>args</code>. Calling <a href="#StatsAPI.fit!-Tuple{Machine}"><code>fit!</code></a> on a <code>Machine</code> instance <code>mach</code> stores outcomes of applying the algorithm in <code>mach</code>, which can be inspected using <code>fitted_params(mach)</code> (learned paramters) and <code>report(mach)</code> (other outcomes). This in turn enables generalization to new data using operations such as <code>predict</code> or <code>transform</code>:</p><pre><code class="language-julia hljs">using MLJModels
X, y = make_regression()

PCA = @load PCA pkg=MultivariateStats
model = PCA()
mach = machine(model, X)
fit!(mach, rows=1:50)
transform(mach, selectrows(X, 51:100)) # or transform(mach, rows=51:100)

DecisionTreeRegressor = @load DecisionTreeRegressor pkg=DecisionTree
model = DecisionTreeRegressor()
mach = machine(model, X, y)
fit!(mach, rows=1:50)
predict(mach, selectrows(X, 51:100)) # or predict(mach, rows=51:100)</code></pre><p>Specify <code>cache=false</code> to prioritize memory management over speed.</p><p>When building a learning network, <code>Node</code> objects can be substituted for the concrete data but no type or dimension checks are applied.</p><p><strong>Checks on the types of training data</strong></p><p>A model articulates its data requirements using <a href="https://juliaai.github.io/ScientificTypes.jl/dev/">scientific types</a>, i.e., using the <a href="@ref"><code>scitype</code></a> function instead of the <code>typeof</code> function.</p><p>If <code>scitype_check_level &gt; 0</code> then the scitype of each <code>arg</code> in <code>args</code> is computed, and this is compared with the scitypes expected by the model, unless <code>args</code> contains <code>Unknown</code> scitypes and <code>scitype_check_level &lt; 4</code>, in which case no further action is taken. Whether warnings are issued or errors thrown depends the level. For details, see <a href="#MLJBase.default_scitype_check_level"><code>default_scitype_check_level</code></a>, a method to inspect or change the default level (<code>1</code> at startup).</p><p><strong>Machines with model placeholders</strong></p><p>A symbol can be substituted for a model in machine constructors to act as a placeholder for a model specified at training time. The symbol must be the field name for a struct whose corresponding value is a model, as shown in the following example:</p><pre><code class="language-julia hljs">mutable struct MyComposite
    transformer
    classifier
end

my_composite = MyComposite(Standardizer(), ConstantClassifier)

X, y = make_blobs()
mach = machine(:classifier, X, y)
fit!(mach, composite=my_composite)</code></pre><p>The last two lines are equivalent to</p><pre><code class="language-julia hljs">mach = machine(ConstantClassifier(), X, y)
fit!(mach)</code></pre><p>Delaying model specification is used when exporting learning networks as new stand-alone model types. See <a href="@ref"><code>prefit</code></a> and the MLJ documentation on learning networks.</p><p>See also <a href="#StatsAPI.fit!-Tuple{Machine}"><code>fit!</code></a>, <a href="#MLJBase.default_scitype_check_level"><code>default_scitype_check_level</code></a>, <a href="#MLJModelInterface.save-Tuple{Machine}"><code>MLJBase.save</code></a>, <a href="#MLJBase.serializable-Union{Tuple{Machine{&lt;:Any, &lt;:Any, C}}, Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Any}} where C"><code>serializable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL254-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.machine-Tuple{Union{IO, String}}" href="#MLJBase.machine-Tuple{Union{IO, String}}"><code>MLJBase.machine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine(file::Union{String, IO})</code></pre><p>Rebuild from a file a machine that has been serialized using the default Serialization module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL397-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.report-Tuple{Machine}" href="#MLJBase.report-Tuple{Machine}"><code>MLJBase.report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report(mach)</code></pre><p>Return the report for a machine <code>mach</code> that has been <code>fit!</code>, for example the coefficients in a linear model.</p><p>This is a named tuple and human-readable if possible.</p><p>If <code>mach</code> is a machine for a composite model, such as a model constructed using the pipeline syntax <code>model1 |&gt; model2 |&gt; ...</code>, then the returned named tuple has the composite type&#39;s field names as keys. The corresponding value is the report for the machine in the underlying learning network bound to that model. (If multiple machines share the same model, then the value is a vector.)</p><pre><code class="language-julia-repl hljs">julia&gt; using MLJ
julia&gt; @load LinearBinaryClassifier pkg=GLM
julia&gt; X, y = @load_crabs;
julia&gt; pipe = Standardizer() |&gt; LinearBinaryClassifier();
julia&gt; mach = machine(pipe, X, y) |&gt; fit!;

julia&gt; report(mach).linear_binary_classifier
(deviance = 3.8893386087844543e-7,
 dof_residual = 195.0,
 stderror = [18954.83496713119, 6502.845740757159, 48484.240246060406, 34971.131004997274, 20654.82322484894, 2111.1294584763386],
 vcov = [3.592857686311793e8 9.122732393971942e6 … -8.454645589364915e7 5.38856837634321e6; 9.122732393971942e6 4.228700272808351e7 … -4.978433790526467e7 -8.442545425533723e6; … ; -8.454645589364915e7 -4.978433790526467e7 … 4.2662172244975924e8 2.1799125705781363e7; 5.38856837634321e6 -8.442545425533723e6 … 2.1799125705781363e7 4.456867590446599e6],)
</code></pre><p>See also <a href="#MLJModelInterface.fitted_params-Tuple{Machine}"><code>fitted_params</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL834-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.report_given_method-Tuple{Machine}" href="#MLJBase.report_given_method-Tuple{Machine}"><code>MLJBase.report_given_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report_given_method(mach::Machine)</code></pre><p>Same as <code>report(mach)</code> but broken down by the method (<code>fit</code>, <code>predict</code>, etc) that contributed the report.</p><p>A specialized method intended for learning network applications.</p><p>The return value is a dictionary keyed on the symbol representing the method (<code>:fit</code>, <code>:predict</code>, etc) and the values report contributed by that method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL874-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.restore!" href="#MLJBase.restore!"><code>MLJBase.restore!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restore!(mach::Machine)</code></pre><p>Restore the state of a machine that is currently serializable but which may not be otherwise usable. For such a machine, <code>mach</code>, one has <code>mach.state=1</code>. Intended for restoring deserialized machine objects to a useable form.</p><p>For an example see <a href="#MLJBase.serializable-Union{Tuple{Machine{&lt;:Any, &lt;:Any, C}}, Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Any}} where C"><code>serializable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL1013-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.serializable-Union{Tuple{Machine{&lt;:Any, &lt;:Any, C}}, Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Any}} where C" href="#MLJBase.serializable-Union{Tuple{Machine{&lt;:Any, &lt;:Any, C}}, Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Any}} where C"><code>MLJBase.serializable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">serializable(mach::Machine)</code></pre><p>Returns a shallow copy of the machine to make it serializable. In particular, all training data is removed and, if necessary, learned parameters are replaced with persistent representations.</p><p>Any general purpose Julia serializer may be applied to the output of <code>serializable</code> (eg, JLSO, BSON, JLD) but you must call <code>restore!(mach)</code> on the deserialised object <code>mach</code> before using it. See the example below.</p><p>If using Julia&#39;s standard Serialization library, a shorter workflow is available using the <a href="#MLJModelInterface.save-Tuple{Machine}"><code>MLJBase.save</code></a> (or <code>MLJ.save</code>) method.</p><p>A machine returned by <code>serializable</code> is characterized by the property <code>mach.state == -1</code>.</p><p><strong>Example using <a href="https://invenia.github.io/JLSO.jl/stable/">JLSO</a></strong></p><pre><code class="language-julia hljs">using MLJ
using JLSO
Tree = @load DecisionTreeClassifier
tree = Tree()
X, y = @load_iris
mach = fit!(machine(tree, X, y))

# This machine can now be serialized
smach = serializable(mach)
JLSO.save(&quot;machine.jlso&quot;, :machine =&gt; smach)

# Deserialize and restore learned parameters to useable form:
loaded_mach = JLSO.load(&quot;machine.jlso&quot;)[:machine]
restore!(loaded_mach)

predict(loaded_mach, X)
predict(mach, X)</code></pre><p>See also <a href="#MLJBase.restore!"><code>restore!</code></a>, <a href="#MLJModelInterface.save-Tuple{Machine}"><code>MLJBase.save</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL941-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.thaw!-Tuple{Machine}" href="#MLJBase.thaw!-Tuple{Machine}"><code>MLJBase.thaw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thaw!(mach)</code></pre><p>Unfreeze the machine <code>mach</code> so that it can be retrained.</p><p>See also <a href="#MLJBase.freeze!-Tuple{Machine}"><code>freeze!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL427-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.feature_importances-Tuple{Machine}" href="#MLJModelInterface.feature_importances-Tuple{Machine}"><code>MLJModelInterface.feature_importances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feature_importances(mach::Machine)</code></pre><p>Return a list of <code>feature =&gt; importance</code> pairs for a fitted machine, <code>mach</code>, for supported models. Otherwise return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL907-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fitted_params-Tuple{Machine}" href="#MLJModelInterface.fitted_params-Tuple{Machine}"><code>MLJModelInterface.fitted_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitted_params(mach)</code></pre><p>Return the learned parameters for a machine <code>mach</code> that has been <code>fit!</code>, for example the coefficients in a linear model.</p><p>This is a named tuple and human-readable if possible.</p><p>If <code>mach</code> is a machine for a composite model, such as a model constructed using the pipeline syntax <code>model1 |&gt; model2 |&gt; ...</code>, then the returned named tuple has the composite type&#39;s field names as keys. The corresponding value is the fitted parameters for the machine in the underlying learning network bound to that model. (If multiple machines share the same model, then the value is a vector.)</p><pre><code class="language-julia-repl hljs">julia&gt; using MLJ
julia&gt; @load LogisticClassifier pkg=MLJLinearModels
julia&gt; X, y = @load_crabs;
julia&gt; pipe = Standardizer() |&gt; LogisticClassifier();
julia&gt; mach = machine(pipe, X, y) |&gt; fit!;

julia&gt; fitted_params(mach).logistic_classifier
(classes = CategoricalArrays.CategoricalValue{String,UInt32}[&quot;B&quot;, &quot;O&quot;],
 coefs = Pair{Symbol,Float64}[:FL =&gt; 3.7095037897680405, :RW =&gt; 0.1135739140854546, :CL =&gt; -1.6036892745322038, :CW =&gt; -4.415667573486482, :BD =&gt; 3.238476051092471],
 intercept = 0.0883301599726305,)</code></pre><p>See also <a href="#MLJBase.report-Tuple{Machine}"><code>report</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL796-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.save-Tuple{Machine}" href="#MLJModelInterface.save-Tuple{Machine}"><code>MLJModelInterface.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MLJ.save(mach)
MLJBase.save(mach)</code></pre><p>Save the current machine as an artifact at the location associated with <code>default_logger</code>](@ref).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL1100-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.save-Tuple{Union{IO, String}, Machine}" href="#MLJModelInterface.save-Tuple{Union{IO, String}, Machine}"><code>MLJModelInterface.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MLJ.save(filename, mach::Machine)
MLJ.save(io, mach::Machine)

MLJBase.save(filename, mach::Machine)
MLJBase.save(io, mach::Machine)</code></pre><p>Serialize the machine <code>mach</code> to a file with path <code>filename</code>, or to an input/output stream <code>io</code> (at least <code>IOBuffer</code> instances are supported) using the Serialization module.</p><p>To serialise using a different format, see <a href="#MLJBase.serializable-Union{Tuple{Machine{&lt;:Any, &lt;:Any, C}}, Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Any}} where C"><code>serializable</code></a>.</p><p>Machines are deserialized using the <code>machine</code> constructor as shown in the example below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The implementation of <code>save</code> for machines changed in MLJ 0.18 (MLJBase 0.20). You can only restore a machine saved using older versions of MLJ using an older version.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">using MLJ
Tree = @load DecisionTreeClassifier
X, y = @load_iris
mach = fit!(machine(Tree(), X, y))

MLJ.save(&quot;tree.jls&quot;, mach)
mach_predict_only = machine(&quot;tree.jls&quot;)
predict(mach_predict_only, X)

# using a buffer:
io = IOBuffer()
MLJ.save(io, mach)
seekstart(io)
predict_only_mach = machine(io)
predict(predict_only_mach, X)</code></pre><div class="admonition is-warning"><header class="admonition-header">Only load files from trusted sources</header><div class="admonition-body"><p>Maliciously constructed JLS files, like pickles, and most other general purpose serialization formats, can allow for arbitrary code execution during loading. This means it is possible for someone to use a JLS file that looks like a serialized MLJ machine as a <a href="https://en.wikipedia.org/wiki/Trojan_horse_(computing)">Trojan horse</a>.</p></div></div><p>See also <a href="#MLJBase.serializable-Union{Tuple{Machine{&lt;:Any, &lt;:Any, C}}, Tuple{C}, Tuple{Machine{&lt;:Any, &lt;:Any, C}, Any}} where C"><code>serializable</code></a>, <a href="#MLJBase.machine"><code>machine</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL1032-L1082">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit!-Tuple{Machine}" href="#StatsAPI.fit!-Tuple{Machine}"><code>StatsAPI.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(mach::Machine, rows=nothing, verbosity=1, force=false, composite=nothing)</code></pre><p>Fit the machine <code>mach</code>. In the case that <code>mach</code> has <code>Node</code> arguments, first train all other machines on which <code>mach</code> depends.</p><p>To attempt to fit a machine without touching any other machine, use <code>fit_only!</code>. For more on options and the the internal logic of fitting see <a href="#MLJBase.fit_only!-Union{Tuple{Machine{&lt;:Any, &lt;:Any, cache_data}}, Tuple{cache_data}} where cache_data"><code>fit_only!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/machines.jl#LL775-L786">source</a></section></article><h2 id="Parameter-Inspection"><a class="docs-heading-anchor" href="#Parameter-Inspection">Parameter Inspection</a><a id="Parameter-Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Inspection" title="Permalink"></a></h2><h2 id="Show"><a class="docs-heading-anchor" href="#Show">Show</a><a id="Show-1"></a><a class="docs-heading-anchor-permalink" href="#Show" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase._recursive_show-Tuple{IO, MLJType, Any, Any}" href="#MLJBase._recursive_show-Tuple{IO, MLJType, Any, Any}"><code>MLJBase._recursive_show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_recursive_show(stream, object, current_depth, depth)</code></pre><p><strong>Private method.</strong></p><p>Generate a table of the properties of the <code>MLJType</code> object, dislaying each property value by calling the method <code>_show</code> on it. The behaviour of <code>_show(stream, f)</code> is as follows:</p><ol><li><p>If <code>f</code> is itself a <code>MLJType</code> object, then its short form is shown and <code>_recursive_show</code> generates as separate table for each of its properties (and so on, up to a depth of argument <code>depth</code>).</p></li><li><p>Otherwise <code>f</code> is displayed as &quot;(omitted T)&quot; where <code>T = typeof(f)</code>, unless <code>istoobig(f)</code> is false (the <code>istoobig</code> fall-back for arbitrary types being <code>true</code>). In the latter case, the long (ie, MIME&quot;plain/text&quot;) form of <code>f</code> is shown. To override this behaviour, overload the <code>_show</code> method for the type in question.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL291-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.abbreviated-Tuple{Any}" href="#MLJBase.abbreviated-Tuple{Any}"><code>MLJBase.abbreviated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abbreviated(n)</code></pre><p>Display abbreviated versions of integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.color_off-Tuple{}" href="#MLJBase.color_off-Tuple{}"><code>MLJBase.color_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_off()</code></pre><p>Suppress color and bold output at the REPL for displaying MLJ objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.color_on-Tuple{}" href="#MLJBase.color_on-Tuple{}"><code>MLJBase.color_on</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_on()</code></pre><p>Enable color and bold output at the REPL, for enhanced display of MLJ objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.handle-Tuple{Any}" href="#MLJBase.handle-Tuple{Any}"><code>MLJBase.handle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">handle(X)</code></pre><p>return abbreviated object id (as string) or it&#39;s registered handle (as string) if this exists</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@constant-Tuple{Any}" href="#MLJBase.@constant-Tuple{Any}"><code>MLJBase.@constant</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@constant x = value</code></pre><p>Private method (used in testing).</p><p>Equivalent to <code>const x = value</code> but registers the binding thus:</p><pre><code class="language-julia hljs">MLJBase.HANDLE_GIVEN_ID[objectid(value)] = :x</code></pre><p>Registered objects get displayed using the variable name to which it was bound in calls to <code>show(x)</code>, etc.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As with any <code>const</code> declaration, binding <code>x</code> to new value of the same type is not prevented and the registration will not be updated.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL23-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@more-Tuple{}" href="#MLJBase.@more-Tuple{}"><code>MLJBase.@more</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@more</code></pre><p>Entered at the REPL, equivalent to <code>show(ans, 100)</code>. Use to get a recursive description of all properties of the last REPL value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/show.jl#LL193-L199">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase._permute_rows-Tuple{AbstractVecOrMat, Vector{Int64}}" href="#MLJBase._permute_rows-Tuple{AbstractVecOrMat, Vector{Int64}}"><code>MLJBase._permute_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_permute_rows(obj, perm)</code></pre><p>Internal function to return a vector or matrix with permuted rows given the permutation <code>perm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.available_name-Tuple{Any, Any}" href="#MLJBase.available_name-Tuple{Any, Any}"><code>MLJBase.available_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available_name(modl::Module, name::Symbol)</code></pre><p>Function to replace, if necessary, a given <code>name</code> with a modified one that ensures it is not the name of any existing object in the global scope of <code>modl</code>. Modifications are created with numerical suffixes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL385-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.check_same_nrows-Tuple{Any, Any}" href="#MLJBase.check_same_nrows-Tuple{Any, Any}"><code>MLJBase.check_same_nrows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_same_nrows(X, Y)</code></pre><p>Internal function to check two objects, each a vector or a matrix, have the same number of rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.chunks-Tuple{AbstractRange, Integer}" href="#MLJBase.chunks-Tuple{AbstractRange, Integer}"><code>MLJBase.chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chunks(range, n)</code></pre><p>Split an <code>AbstractRange</code>  into <code>n</code> subranges of approximately equal length.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(chunks(1:5, 2))
2-element Vector{UnitRange{Int64}}:
 1:3
 4:5</code></pre><p><strong>Private method</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL342-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.flat_values-Tuple{NamedTuple}" href="#MLJBase.flat_values-Tuple{NamedTuple}"><code>MLJBase.flat_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flat_values(t::NamedTuple)</code></pre><p>View a nested named tuple <code>t</code> as a tree and return, as a tuple, the values at the leaves, in the order they appear in the original tuple.</p><pre><code class="language-julia-repl hljs">julia&gt; t = (X = (x = 1, y = 2), Y = 3);
julia&gt; flat_values(t)
(1, 2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.generate_name!-Tuple{DataType, Any}" href="#MLJBase.generate_name!-Tuple{DataType, Any}"><code>MLJBase.generate_name!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_name!(M, existing_names; only=Union{Function,Type}, substitute=:f)</code></pre><p>Given a type <code>M</code> (e.g., <code>MyEvenInteger{N}</code>) return a symbolic, snake-case, representation of the type name (such as <code>my_even_integer</code>). The symbol is pushed to <code>existing_names</code>, which must be an <code>AbstractVector</code> to which a <code>Symbol</code> can be pushed.</p><p>If the snake-case representation already exists in <code>existing_names</code> a suitable integer is appended to the name.</p><p>If <code>only</code> is specified, then the operation is restricted to those <code>M</code> for which <code>M isa only</code>. In all other cases the symbolic name is generated using <code>substitute</code> as the base symbol.</p><pre><code class="language-julia-repl hljs">julia&gt; existing_names = [];
julia&gt; generate_name!(Vector{Int}, existing_names)
:vector

julia&gt; generate_name!(Vector{Int}, existing_names)
:vector2

julia&gt; generate_name!(AbstractFloat, existing_names)
:abstract_float

julia&gt; generate_name!(Int, existing_names, only=Array, substitute=:not_array)
:not_array

julia&gt; generate_name!(Int, existing_names, only=Array, substitute=:not_array)
:not_array2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL403-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.guess_model_target_observation_scitype-Tuple{Any}" href="#MLJBase.guess_model_target_observation_scitype-Tuple{Any}"><code>MLJBase.guess_model_target_observation_scitype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">guess_model_targetobservation_scitype(model)</code></pre><p><em>Private method</em></p><p>Try to infer a lowest upper bound on the scitype of target observations acceptable to <code>model</code>, by inspecting <code>target_scitype(model)</code>. Return <code>Unknown</code> if unable to draw reliable inferrence.</p><p>The observation scitype for a table is here understood as the scitype of a row converted to a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL537-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.guess_observation_scitype-Tuple{Any}" href="#MLJBase.guess_observation_scitype-Tuple{Any}"><code>MLJBase.guess_observation_scitype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">guess_observation_scitype(y)</code></pre><p><em>Private method.</em></p><p>If <code>y</code> is an <code>AbstractArray</code>, return the scitype of <code>y[:, :, ..., :, 1]</code>. If <code>y</code> is a table, return the scitype of the first row, converted to a vector, unless this row has <code>missing</code> elements, in which case return <code>Unknown</code>.</p><p>In all other cases, <code>Unknown</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; guess_observation_scitype([missing, 1, 2, 3])
Union{Missing, Count}

julia&gt; guess_observation_scitype(rand(3, 2))
AbstractVector{Continuous}

julia&gt; guess_observation_scitype((x=rand(3), y=rand(Bool, 3)))
AbstractVector{Union{Continuous, Count}}

julia&gt; guess_observation_scitype((x=[missing, 1, 2], y=[1, 2, 3]))
Unknown</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL502-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.init_rng-Tuple{Any}" href="#MLJBase.init_rng-Tuple{Any}"><code>MLJBase.init_rng</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_rng(rng)</code></pre><p>Create an <code>AbstractRNG</code> from <code>rng</code>. If <code>rng</code> is a non-negative <code>Integer</code>, it returns a <code>MersenneTwister</code> random number generator seeded with <code>rng</code>; If <code>rng</code> is an <code>AbstractRNG</code> object it returns <code>rng</code>, otherwise it throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL187-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.observation-Tuple{Type}" href="#MLJBase.observation-Tuple{Type}"><code>MLJBase.observation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observation(S)</code></pre><p><em>Private method.</em></p><p>Tries to infer the per-observation scitype from the scitype of <code>S</code>, when <code>S</code> is known to be the scitype of some container with multiple observations. Return <code>Unknown</code> if unable to draw reliable inferrence.</p><p>The observation scitype for a table is here understood as the scitype of a row converted to a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL473-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.prepend-Tuple{Symbol, Nothing}" href="#MLJBase.prepend-Tuple{Symbol, Nothing}"><code>MLJBase.prepend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MLJBase.prepend(::Symbol, ::Union{Symbol,Expr,Nothing})</code></pre><p>For prepending symbols in expressions like <code>:(y.w)</code> and <code>:(x1.x2.x3)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; prepend(:x, :y)
:(x.y)

julia&gt; prepend(:x, :(y.z))
:(x.y.z)

julia&gt; prepend(:w, ans)
:(w.x.y.z)</code></pre><p>If the second argument is <code>nothing</code>, then <code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL49-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.recursive_getproperty-Tuple{Any, Symbol}" href="#MLJBase.recursive_getproperty-Tuple{Any, Symbol}"><code>MLJBase.recursive_getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recursive_getproperty(object, nested_name::Expr)</code></pre><p>Call getproperty recursively on <code>object</code> to extract the value of some nested property, as in the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; object = (X = (x = 1, y = 2), Y = 3);
julia&gt; recursive_getproperty(object, :(X.y))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL73-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.recursive_setproperty!-Tuple{Any, Symbol, Any}" href="#MLJBase.recursive_setproperty!-Tuple{Any, Symbol, Any}"><code>MLJBase.recursive_setproperty!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recursively_setproperty!(object, nested_name::Expr, value)</code></pre><p>Set a nested property of an <code>object</code> to <code>value</code>, as in the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Foo
           X
           Y
       end

julia&gt; mutable struct Bar
           x
           y
       end

julia&gt; object = Foo(Bar(1, 2), 3)
Foo(Bar(1, 2), 3)

julia&gt; recursively_setproperty!(object, :(X.y), 42)
42

julia&gt; object
Foo(Bar(1, 42), 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL106-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.sequence_string-Union{Tuple{Itr}, Tuple{Itr, Any}} where Itr" href="#MLJBase.sequence_string-Union{Tuple{Itr}, Tuple{Itr, Any}} where Itr"><code>MLJBase.sequence_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sequence_string(itr, n=3)</code></pre><p>Return a &quot;sequence&quot; string from the first <code>n</code> elements generated by <code>itr</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; MLJBase.sequence_string(1:10, 4)
&quot;1, 2, 3, 4, ...&quot;</code></pre><p><strong>Private method.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL249-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.shuffle_rows-Tuple{AbstractVecOrMat, AbstractVecOrMat}" href="#MLJBase.shuffle_rows-Tuple{AbstractVecOrMat, AbstractVecOrMat}"><code>MLJBase.shuffle_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shuffle_rows(X::AbstractVecOrMat,
             Y::AbstractVecOrMat;
             rng::AbstractRNG=Random.GLOBAL_RNG)</code></pre><p>Return row-shuffled vectors or matrices using a random permutation of <code>X</code> and <code>Y</code>. An optional random number generator can be specified using the <code>rng</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL167-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.unwind-Tuple" href="#MLJBase.unwind-Tuple"><code>MLJBase.unwind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unwind(iterators...)</code></pre><p>Represent all possible combinations of values generated by <code>iterators</code> as rows of a matrix <code>A</code>. In more detail, <code>A</code> has one column for each iterator in <code>iterators</code> and one row for each distinct possible combination of values taken on by the iterators. Elements in the first column cycle fastest, those in the last clolumn slowest.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iterators = ([1, 2], [&quot;a&quot;,&quot;b&quot;], [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);
julia&gt; MLJTuning.unwind(iterators...)
12×3 Matrix{Any}:
 1  &quot;a&quot;  &quot;x&quot;
 2  &quot;a&quot;  &quot;x&quot;
 1  &quot;b&quot;  &quot;x&quot;
 2  &quot;b&quot;  &quot;x&quot;
 1  &quot;a&quot;  &quot;y&quot;
 2  &quot;a&quot;  &quot;y&quot;
 1  &quot;b&quot;  &quot;y&quot;
 2  &quot;b&quot;  &quot;y&quot;
 1  &quot;a&quot;  &quot;z&quot;
 2  &quot;a&quot;  &quot;z&quot;
 1  &quot;b&quot;  &quot;z&quot;
 2  &quot;b&quot;  &quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/f80511f80e135c9a1e8168d3bd38e87884d01ae9/src/utilities.jl#LL290-L319">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributions/">« Distributions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 28 October 2025 06:40">Tuesday 28 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
