<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributions · MLJBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MLJBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../resampling/">Resampling</a></li><li><a class="tocitem" href="../composition/">Composition</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li class="is-active"><a class="tocitem" href>Distributions</a><ul class="internal"><li><a class="tocitem" href="#Univariate-Finite-Distribution"><span>Univariate Finite Distribution</span></a></li><li><a class="tocitem" href="#hyperparameters"><span>hyperparameters</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li></ul></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Distributions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distributions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/MLJBase.jl/blob/dev/docs/src/distributions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Distributions"><a class="docs-heading-anchor" href="#Distributions">Distributions</a><a id="Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Distributions" title="Permalink"></a></h1><h2 id="Univariate-Finite-Distribution"><a class="docs-heading-anchor" href="#Univariate-Finite-Distribution">Univariate Finite Distribution</a><a id="Univariate-Finite-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Finite-Distribution" title="Permalink"></a></h2><h2 id="hyperparameters"><a class="docs-heading-anchor" href="#hyperparameters">hyperparameters</a><a id="hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#hyperparameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Distributions.sampler-Union{Tuple{T}, Tuple{NumericRange{T}, Distributions.UnivariateDistribution}} where T" href="#Distributions.sampler-Union{Tuple{T}, Tuple{NumericRange{T}, Distributions.UnivariateDistribution}} where T"><code>Distributions.sampler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampler(r::NominalRange, probs::AbstractVector{&lt;:Real})
sampler(r::NominalRange)
sampler(r::NumericRange{T}, d)</code></pre><p>Construct an object <code>s</code> which can be used to generate random samples from a <code>ParamRange</code> object <code>r</code> (a one-dimensional range) using one of the following calls:</p><pre><code class="language-julia hljs">rand(s)             # for one sample
rand(s, n)          # for n samples
rand(rng, s [, n])  # to specify an RNG</code></pre><p>The argument <code>probs</code> can be any probability vector with the same length as <code>r.values</code>. The second <code>sampler</code> method above calls the first with a uniform <code>probs</code> vector.</p><p>The argument <code>d</code> can be either an arbitrary instance of <code>UnivariateDistribution</code> from the Distributions.jl package, or one of a Distributions.jl <em>types</em> for which <code>fit(d, ::NumericRange)</code> is defined. These include: <code>Arcsine</code>, <code>Uniform</code>, <code>Biweight</code>, <code>Cosine</code>, <code>Epanechnikov</code>, <code>SymTriangularDist</code>, <code>Triweight</code>, <code>Normal</code>, <code>Gamma</code>, <code>InverseGaussian</code>, <code>Logistic</code>, <code>LogNormal</code>, <code>Cauchy</code>, <code>Gumbel</code>, <code>Laplace</code>, and <code>Poisson</code>; but see the doc-string for <a href="#StatsAPI.fit-Union{Tuple{D}, Tuple{Type{D}, NumericRange}} where D&lt;:Distributions.Distribution"><code>Distributions.fit</code></a> for an up-to-date list.</p><p>If <code>d</code> is an <em>instance</em>, then sampling is from a truncated form of the supplied distribution <code>d</code>, the truncation bounds being <code>r.lower</code> and <code>r.upper</code> (the attributes <code>r.origin</code> and <code>r.unit</code> attributes are ignored). For discrete numeric ranges (<code>T &lt;: Integer</code>) the samples are rounded.</p><p>If <code>d</code> is a <em>type</em> then a suitably truncated distribution is automatically generated using <code>Distributions.fit(d, r)</code>.</p><p><em>Important.</em> Values are generated with no regard to <code>r.scale</code>, except in the special case <code>r.scale</code> is a callable object <code>f</code>. In that case, <code>f</code> is applied to all values generated by <code>rand</code> as described above (prior to rounding, in the case of discrete numeric ranges).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = range(Char, :letter, values=collect(&quot;abc&quot;))
julia&gt; s = sampler(r, [0.1, 0.2, 0.7])
julia&gt; samples =  rand(s, 1000);
julia&gt; StatsBase.countmap(samples)
Dict{Char,Int64} with 3 entries:
  &#39;a&#39; =&gt; 107
  &#39;b&#39; =&gt; 205
  &#39;c&#39; =&gt; 688

julia&gt; r = range(Int, :k, lower=2, upper=6) # numeric but discrete
julia&gt; s = sampler(r, Normal)
julia&gt; samples = rand(s, 1000);
julia&gt; UnicodePlots.histogram(samples)
           ┌                                        ┐
[2.0, 2.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 119
[2.5, 3.0) ┤ 0
[3.0, 3.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 296
[3.5, 4.0) ┤ 0
[4.0, 4.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 275
[4.5, 5.0) ┤ 0
[5.0, 5.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 221
[5.5, 6.0) ┤ 0
[6.0, 6.5) ┤▇▇▇▇▇▇▇▇▇▇▇ 89
           └                                        ┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/14441aa04996b00ab2f54974c28b8b7be89286ff/src/hyperparam/one_dimensional_range_methods.jl#LL290-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.iterator-Tuple{Random.AbstractRNG, ParamRange, Vararg{Any}}" href="#MLJBase.iterator-Tuple{Random.AbstractRNG, ParamRange, Vararg{Any}}"><code>MLJBase.iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterator([rng, ], r::NominalRange, [,n])
iterator([rng, ], r::NumericRange, n)</code></pre><p>Return an iterator (currently a vector) for a <code>ParamRange</code> object <code>r</code>. In the first case iteration is over all <code>values</code> stored in the range (or just the first <code>n</code>, if <code>n</code> is specified). In the second case, the iteration is over approximately <code>n</code> ordered values, generated as follows:</p><p>(i) First, exactly <code>n</code> values are generated between <code>U</code> and <code>L</code>, with a spacing determined by <code>r.scale</code> (uniform if <code>scale=:linear</code>) where <code>U</code> and <code>L</code> are given by the following table:</p><table><tr><th style="text-align: right"><code>r.lower</code></th><th style="text-align: right"><code>r.upper</code></th><th style="text-align: right"><code>L</code></th><th style="text-align: right"><code>U</code></th></tr><tr><td style="text-align: right">finite</td><td style="text-align: right">finite</td><td style="text-align: right"><code>r.lower</code></td><td style="text-align: right"><code>r.upper</code></td></tr><tr><td style="text-align: right"><code>-Inf</code></td><td style="text-align: right">finite</td><td style="text-align: right"><code>r.upper - 2r.unit</code></td><td style="text-align: right"><code>r.upper</code></td></tr><tr><td style="text-align: right">finite</td><td style="text-align: right"><code>Inf</code></td><td style="text-align: right"><code>r.lower</code></td><td style="text-align: right"><code>r.lower + 2r.unit</code></td></tr><tr><td style="text-align: right"><code>-Inf</code></td><td style="text-align: right"><code>Inf</code></td><td style="text-align: right"><code>r.origin - r.unit</code></td><td style="text-align: right"><code>r.origin + r.unit</code></td></tr></table><p>(ii) If a callable <code>f</code> is provided as <code>scale</code>, then a uniform spacing is always applied in (i) but <code>f</code> is broadcast over the results. (Unlike ordinary scales, this alters the effective range of values generated, instead of just altering the spacing.)</p><p>(iii) If <code>r</code> is a discrete numeric range (<code>r isa NumericRange{&lt;:Integer}</code>) then the values are additionally rounded, with any duplicate values removed. Otherwise all the values are used (and there are exacltly <code>n</code> of them).</p><p>(iv) Finally, if a random number generator <code>rng</code> is specified, then the values are returned in random order (sampling without replacement), and otherwise they are returned in numeric order, or in the order provided to the range constructor, in the case of a <code>NominalRange</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/14441aa04996b00ab2f54974c28b8b7be89286ff/src/hyperparam/one_dimensional_range_methods.jl#LL59-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.scale-Tuple{NominalRange}" href="#MLJBase.scale-Tuple{NominalRange}"><code>MLJBase.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(r::ParamRange)</code></pre><p>Return the scale associated with a <code>ParamRange</code> object <code>r</code>. The possible return values are: <code>:none</code> (for a <code>NominalRange</code>), <code>:linear</code>, <code>:log</code>, <code>:log10</code>, <code>:log2</code>, or <code>:custom</code> (if <code>r.scale</code> is a callable object).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/14441aa04996b00ab2f54974c28b8b7be89286ff/src/hyperparam/one_dimensional_range_methods.jl#LL45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{D}, Tuple{Type{D}, NumericRange}} where D&lt;:Distributions.Distribution" href="#StatsAPI.fit-Union{Tuple{D}, Tuple{Type{D}, NumericRange}} where D&lt;:Distributions.Distribution"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Distributions.fit(D, r::MLJBase.NumericRange)</code></pre><p>Fit and return a distribution <code>d</code> of type <code>D</code> to the one-dimensional range <code>r</code>.</p><p>Only types <code>D</code> in the table below are supported.</p><p>The distribution <code>d</code> is constructed in two stages. First, a distributon <code>d0</code>, characterized by the conditions in the second column of the table, is fit to <code>r</code>. Then <code>d0</code> is truncated between <code>r.lower</code> and <code>r.upper</code> to obtain <code>d</code>.</p><table><tr><th style="text-align: left">Distribution type <code>D</code></th><th style="text-align: left">Characterization of <code>d0</code></th></tr><tr><td style="text-align: left"><code>Arcsine</code>, <code>Uniform</code>, <code>Biweight</code>, <code>Cosine</code>, <code>Epanechnikov</code>, <code>SymTriangularDist</code>, <code>Triweight</code></td><td style="text-align: left"><code>minimum(d) = r.lower</code>, <code>maximum(d) = r.upper</code></td></tr><tr><td style="text-align: left"><code>Normal</code>, <code>Gamma</code>, <code>InverseGaussian</code>, <code>Logistic</code>, <code>LogNormal</code></td><td style="text-align: left"><code>mean(d) = r.origin</code>, <code>std(d) = r.unit</code></td></tr><tr><td style="text-align: left"><code>Cauchy</code>, <code>Gumbel</code>, <code>Laplace</code>, (<code>Normal</code>)</td><td style="text-align: left"><code>Dist.location(d) = r.origin</code>, <code>Dist.scale(d)  = r.unit</code></td></tr><tr><td style="text-align: left"><code>Poisson</code></td><td style="text-align: left"><code>Dist.mean(d) = r.unit</code></td></tr></table><p>Here <code>Dist = Distributions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/14441aa04996b00ab2f54974c28b8b7be89286ff/src/hyperparam/one_dimensional_range_methods.jl#LL180-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.range-Union{Tuple{D}, Tuple{Union{Model, Type}, Union{Expr, Symbol}}} where D" href="#Base.range-Union{Tuple{D}, Tuple{Union{Model, Type}, Union{Expr, Symbol}}} where D"><code>Base.range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r = range(model, :hyper; values=nothing)</code></pre><p>Define a one-dimensional <code>NominalRange</code> object for a field <code>hyper</code> of <code>model</code>. Note that <code>r</code> is not directly iterable but <code>iterator(r)</code> is.</p><p>A nested hyperparameter is specified using dot notation. For example, <code>:(atom.max_depth)</code> specifies the <code>max_depth</code> hyperparameter of the submodel <code>model.atom</code>.</p><pre><code class="nohighlight hljs">r = range(model, :hyper; upper=nothing, lower=nothing,
          scale=nothing, values=nothing)</code></pre><p>Assuming <code>values</code> is not specified, define a one-dimensional <code>NumericRange</code> object for a <code>Real</code> field <code>hyper</code> of <code>model</code>.  Note that <code>r</code> is not directly iteratable but <code>iterator(r, n)</code>is an iterator of length <code>n</code>. To generate random elements from <code>r</code>, instead apply <code>rand</code> methods to <code>sampler(r)</code>. The supported scales are <code>:linear</code>,<code>:log</code>, <code>:logminus</code>, <code>:log10</code>, <code>:log10minus</code>, <code>:log2</code>, or a callable object.</p><p>Note that <code>r</code> is not directly iterable, but <code>iterator(r, n)</code> is, for given resolution (length) <code>n</code>.</p><p>By default, the behaviour of the constructed object depends on the type of the value of the hyperparameter <code>:hyper</code> at <code>model</code> <em>at the time of construction.</em> To override this behaviour (for instance if <code>model</code> is not available) specify a type in place of <code>model</code> so the behaviour is determined by the value of the specified type.</p><p>A nested hyperparameter is specified using dot notation (see above).</p><p>If <code>scale</code> is unspecified, it is set to <code>:linear</code>, <code>:log</code>, <code>:log10minus</code>, or <code>:linear</code>, according to whether the interval <code>(lower, upper)</code> is bounded, right-unbounded, left-unbounded, or doubly unbounded, respectively.  Note <code>upper=Inf</code> and <code>lower=-Inf</code> are allowed.</p><p>If <code>values</code> is specified, the other keyword arguments are ignored and a <code>NominalRange</code> object is returned (see above).</p><p>See also: <a href="#MLJBase.iterator-Tuple{Random.AbstractRNG, ParamRange, Vararg{Any}}"><code>iterator</code></a>, <a href="#Distributions.sampler-Union{Tuple{T}, Tuple{NumericRange{T}, Distributions.UnivariateDistribution}} where T"><code>sampler</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/MLJBase.jl/blob/14441aa04996b00ab2f54974c28b8b7be89286ff/src/hyperparam/one_dimensional_ranges.jl#LL90-L133">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datasets/">« Datasets</a><a class="docs-footer-nextpage" href="../utilities/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 8 May 2024 21:32">Wednesday 8 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
