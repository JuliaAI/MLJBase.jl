<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Composition · MLJBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MLJBase.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../measures/">Measures</a></li><li><a class="tocitem" href="../resampling/">Resampling</a></li><li class="is-active"><a class="tocitem" href>Composition</a><ul class="internal"><li><a class="tocitem" href="#Composites-1"><span>Composites</span></a></li><li><a class="tocitem" href="#Networks-1"><span>Networks</span></a></li><li><a class="tocitem" href="#Pipelines-1"><span>Pipelines</span></a></li></ul></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../openml/">OpenML</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Composition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Composition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/master/docs/src/composition.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Composition-1"><a class="docs-heading-anchor" href="#Composition-1">Composition</a><a class="docs-heading-anchor-permalink" href="#Composition-1" title="Permalink"></a></h1><h2 id="Composites-1"><a class="docs-heading-anchor" href="#Composites-1">Composites</a><a class="docs-heading-anchor-permalink" href="#Composites-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.anonymize!-Tuple" href="#MLJBase.anonymize!-Tuple"><code>MLJBase.anonymize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">anonymize!(sources...)</code></pre><p>Returns a named tuple <code>(sources=..., data=....)</code> whose values are the provided source nodes and their contents respectively, and clears the contents of those source nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/composites.jl#LL73-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@from_network-Tuple" href="#MLJBase.@from_network-Tuple"><code>MLJBase.@from_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@from_network(NewCompositeModel(fld1=model1, fld2=model2, ...) &lt;= N
@from_network(NewCompositeModel(fld1=model1, fld2=model2, ...) &lt;= N is_probabilistic=false</code></pre><p>Create a new stand-alone model type called <code>NewCompositeModel</code>, using a learning network as a blueprint. Here <code>N</code> refers to the terminal node of the learning network (from which final predictions or transformations are fetched).</p><p><em>Important.</em> If the learning network is supervised (has a source with <code>kind=:target</code>) and makes probabilistic predictions, then one must declare <code>is_probabilistic=true</code>. In the deterministic case the keyword argument can be omitted.</p><p>The model type <code>NewCompositeModel</code> is equipped with fields named <code>:fld1</code>, <code>:fld2</code>, ..., which correspond to component models <code>model1</code>, <code>model2</code>, ...,  appearing in the network (which must therefore be elements of <code>models(N)</code>).  Deep copies of the specified component models are used as default values in an automatically generated keyword constructor for <code>NewCompositeModel</code>.</p><p><strong>Return value</strong></p><p>A new <code>NewCompositeModel</code> instance, with default field values.</p><p>For details and examples refer to the &quot;Learning Networks&quot; section of the documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/composites.jl#LL433-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{Node,Vararg{Pair,N} where N}" href="#Base.replace-Tuple{Node,Vararg{Pair,N} where N}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace(W::Node, a1=&gt;b1, a2=&gt;b2, ...; empty_unspecified_sources=false)</code></pre><p>Create a deep copy of a node <code>W</code>, and thereby replicate the learning network terminating at <code>W</code>, but replacing any specified sources and models <code>a1, a2, ...</code> of the original network with <code>b1, b2, ...</code>.</p><p>If <code>empty_unspecified_sources=ture</code> then any source nodes not specified are replaced with empty version of the same kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/composites.jl#LL130-L140">source</a></section></article><h2 id="Networks-1"><a class="docs-heading-anchor" href="#Networks-1">Networks</a><a class="docs-heading-anchor-permalink" href="#Networks-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.node" href="#MLJBase.node"><code>MLJBase.node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">N = node(f::Function, args...)</code></pre><p>Defines a <code>Node</code> object <code>N</code> wrapping a static operation <code>f</code> and arguments <code>args</code>. Each of the <code>n</code> elements of <code>args</code> must be a <code>Node</code> or <code>Source</code> object. The node <code>N</code> has the following calling behaviour:</p><pre><code class="language-none">N() = f(args[1](), args[2](), ..., args[n]())
N(rows=r) = f(args[1](rows=r), args[2](rows=r), ..., args[n](rows=r))
N(X) = f(args[1](X), args[2](X), ..., args[n](X))

J = node(f, mach::NodalMachine, args...)</code></pre><p>Defines a dynamic <code>Node</code> object <code>J</code> wrapping a dynamic operation <code>f</code> (<code>predict</code>, <code>predict_mean</code>, <code>transform</code>, etc), a nodal machine <code>mach</code> and arguments <code>args</code>. Its calling behaviour, which depends on the outcome of training <code>mach</code> (and, implicitly, on training outcomes affecting its arguments) is this:</p><pre><code class="language-none">J() = f(mach, args[1](), args[2](), ..., args[n]())
J(rows=r) = f(mach, args[1](rows=r), args[2](rows=r), ..., args[n](rows=r))
J(X) = f(mach, args[1](X), args[2](X), ..., args[n](X))</code></pre><p>Generally <code>n=1</code> or <code>n=2</code> in this latter case.</p><pre><code class="language-none">predict(mach, X::AbsractNode, y::AbstractNode)
predict_mean(mach, X::AbstractNode, y::AbstractNode)
predict_median(mach, X::AbstractNode, y::AbstractNode)
predict_mode(mach, X::AbstractNode, y::AbstractNode)
transform(mach, X::AbstractNode)
inverse_transform(mach, X::AbstractNode)</code></pre><p>Shortcuts for <code>J = node(predict, mach, X, y)</code>, etc.</p><p>Calling a node is a recursive operation which terminates in the call to a source node (or nodes). Calling nodes on <em>new</em> data <code>X</code> fails unless the number of such nodes is one.</p><p>See also: <a href="#MLJBase.source-Tuple{Any}"><code>source</code></a>, <a href="#MLJBase.origins-Tuple{Source}"><code>origins</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL405-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.freeze!-Tuple{NodalMachine}" href="#MLJBase.freeze!-Tuple{NodalMachine}"><code>MLJBase.freeze!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">freeze!(mach)</code></pre><p>Freeze the machine <code>mach</code> so that it will never be retrained (unless thawed).</p><p>See also <a href="#MLJBase.thaw!-Tuple{NodalMachine}"><code>thaw!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.machines-Tuple{Node}" href="#MLJBase.machines-Tuple{Node}"><code>MLJBase.machines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">machines(N)</code></pre><p>List all machines in the learning network terminating at node <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL585-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.models-Tuple{AbstractNode}" href="#MLJBase.models-Tuple{AbstractNode}"><code>MLJBase.models</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">models(N::AbstractNode)</code></pre><p>A vector of all models referenced by a node <code>N</code>, each model appearing exactly once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL543-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.nodes-Tuple{Node}" href="#MLJBase.nodes-Tuple{Node}"><code>MLJBase.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodes(N)</code></pre><p>Return all nodes upstream of a node <code>N</code>, including <code>N</code> itself, in an order consistent with the extended directed acyclic graph of the network. Here &quot;extended&quot; means edges corresponding to training arguments are included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL241-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.origins-Tuple{Source}" href="#MLJBase.origins-Tuple{Source}"><code>MLJBase.origins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">origins(N)</code></pre><p>Return a list of all origins of a node <code>N</code> accessed by a call <code>N()</code>. These are the source nodes of the acyclic directed graph (DAG) associated with the learning network terminating at <code>N</code>, if edges corresponding to training arguments are excluded. A <code>Node</code> object cannot be called on new data unless it has a unique origin.</p><p>Not to be confused with <code>sources(N)</code> which refers to the same graph but without the training edge deletions.</p><p>See also: <a href="#MLJBase.node"><code>node</code></a>, <a href="#MLJBase.source-Tuple{Any}"><code>source</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.rebind!-Tuple{Source,Any}" href="#MLJBase.rebind!-Tuple{Source,Any}"><code>MLJBase.rebind!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rebind!(s)</code></pre><p>Attach new data <code>X</code> to an existing source node <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.source-Tuple{Any}" href="#MLJBase.source-Tuple{Any}"><code>MLJBase.source</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Xs = source(X)
ys = source(y, kind=:target)
ws = source(w, kind=:weight)</code></pre><p>Defines, respectively, learning network <code>Source</code> objects for wrapping some input data <code>X</code> (<code>kind=:input</code>), some target data <code>y</code>, or some sample weights <code>w</code>.  The values of each variable <code>X, y, w</code> can be anything, even <code>nothing</code>, if the network is for exporting as a stand-alone model only. For training and testing the unexported network, appropriate vectors, tables, or other data containers are expected.</p><pre><code class="language-none">Xs = source()
ys = source(kind=:target)
ws = source(kind=:weight)</code></pre><p>Define source nodes wrapping <code>nothing</code> instead of concrete data. Such definitions suffice if a learning network is to be exported without testing.</p><p>The calling behaviour of a <code>Source</code> object is this:</p><pre><code class="language-none">Xs() = X
Xs(rows=r) = selectrows(X, r)  # eg, X[r,:] for a DataFrame
Xs(Xnew) = Xnew</code></pre><p>See also: [<code>@from_network</code>](@ref], <a href="#MLJBase.sources-Tuple{AbstractNode}"><code>sources</code></a>, <a href="#MLJBase.origins-Tuple{Source}"><code>origins</code></a>, <a href="#MLJBase.node"><code>node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL16-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.sources-Tuple{AbstractNode}" href="#MLJBase.sources-Tuple{AbstractNode}"><code>MLJBase.sources</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sources(N::AbstractNode; kind=:any)</code></pre><p>A vector of all sources referenced by calls <code>N()</code> and <code>fit!(N)</code>. These are the sources of the directed acyclic graph associated with the learning network terminating at <code>N</code>, including training edges. The return value can be restricted further by specifying <code>kind=:input</code>, <code>kind=:target</code>, <code>kind=:weight</code>, etc.</p><p>Not to be confused with <code>origins(N)</code> which refers to the same graph with edges corresponding to training arguments deleted.</p><p>See also: <a href="#MLJBase.origins-Tuple{Source}"><code>origins</code></a>, <a href="#MLJBase.source-Tuple{Any}"><code>source</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL557-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.thaw!-Tuple{NodalMachine}" href="#MLJBase.thaw!-Tuple{NodalMachine}"><code>MLJBase.thaw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">thaw!(mach)</code></pre><p>Unfreeze the machine <code>mach</code> so that it can be retrained.</p><p>See also <a href="#MLJBase.freeze!-Tuple{NodalMachine}"><code>freeze!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL165-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.selectcols-Tuple{AbstractNode,Any}" href="#MLJModelInterface.selectcols-Tuple{AbstractNode,Any}"><code>MLJModelInterface.selectcols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">selectcols(X::AbstractNode, c)</code></pre><p>Returns <code>Node</code> object <code>N</code> such that <code>N() = selectcols(X(), c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.selectrows-Tuple{AbstractNode,Any}" href="#MLJModelInterface.selectrows-Tuple{AbstractNode,Any}"><code>MLJModelInterface.selectrows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">selectrows(X::AbstractNode, r)</code></pre><p>Returns a <code>Node</code> object <code>N</code> such that <code>N() = selectrows(X(), r)</code> (and <code>N(rows=s) = selectrows(X(rows=s), r)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL484-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit!-Tuple{Node}" href="#StatsBase.fit!-Tuple{Node}"><code>StatsBase.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(N::Node; rows=nothing, verbosity::Int=1, force::Bool=false)</code></pre><p>Train all machines in the learning network terminating at node <code>N</code>, in an appropriate order. These machines are those returned by <code>machines(N)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL315-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.args-Tuple{Any}" href="#MLJBase.args-Tuple{Any}"><code>MLJBase.args</code></a> — <span class="docstring-category">Method</span></header><section><div><p>args(tree; train=false)</p><p>Return a vector of the top level args of the tree associated with a node. If <code>train=true</code>, return the <code>train_args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL530-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.is_stale-Tuple{NodalMachine}" href="#MLJBase.is_stale-Tuple{NodalMachine}"><code>MLJBase.is_stale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_stale(mach)</code></pre><p>Check if a machine <code>mach</code> is stale.</p><p>See also <a href="#StatsBase.fit!-Tuple{Node}"><code>fit!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL176-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.is_stale-Tuple{Node}" href="#MLJBase.is_stale-Tuple{Node}"><code>MLJBase.is_stale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_stale(N)</code></pre><p>Check if a node <code>N</code> is stale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.reset!-Tuple{Node}" href="#MLJBase.reset!-Tuple{Node}"><code>MLJBase.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset!(N::Node)</code></pre><p>Place the learning network terminating at node <code>N</code> into a state in which <code>fit!(N)</code> will retrain from scratch all machines in its dependency tape. Does not actually train any machine or alter fit-results. (The method simply resets <code>m.state</code> to zero, for every machine <code>m</code> in the network.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL605-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.state-Tuple{NodalMachine}" href="#MLJBase.state-Tuple{NodalMachine}"><code>MLJBase.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(mach)</code></pre><p>Return the state of a machine, <code>mach</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.state-Tuple{Node}" href="#MLJBase.state-Tuple{Node}"><code>MLJBase.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(N)</code></pre><p>Return the state of a node <code>N</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.tree-Tuple{Node}" href="#MLJBase.tree-Tuple{Node}"><code>MLJBase.tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree(N)</code></pre><p>Return a description of the tree <code>N</code> defined by the learning network terminating at a given node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/networks.jl#LL502-L508">source</a></section></article><h2 id="Pipelines-1"><a class="docs-heading-anchor" href="#Pipelines-1">Pipelines</a><a class="docs-heading-anchor-permalink" href="#Pipelines-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@pipeline-Tuple" href="#MLJBase.@pipeline-Tuple"><code>MLJBase.@pipeline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pipeline NewPipeType(fld1=model1, fld2=model2, ...)
@pipeline NewPipeType(fld1=model1, fld2=model2, ...) prediction_type=:probabilistic</code></pre><p>Create a new pipeline model type <code>NewPipeType</code> that composes the types of the specified models <code>model1</code>, <code>model2</code>, ... . The models are composed in the specified order, meaning the input(s) of the pipeline goes to <code>model1</code>, whose output is sent to <code>model2</code>, and so forth.</p><p>At most one of the models may be a supervised model, in which case <code>NewPipeType</code> is supervised. Otherwise it is unsupervised.</p><p>The new model type <code>NewPipeType</code> has hyperparameters (fields) named <code>:fld1</code>, <code>:fld2</code>, ..., whose default values for an automatically generated keyword constructor are deep copies of <code>model1</code>, <code>model2</code>, ... .</p><p><em>Important.</em> If the overall pipeline is supervised and makes probabilistic predictions, then one must declare <code>prediction_type=:probabilistic</code>. In the deterministic case no declaration is necessary.</p><p>Static (unlearned) transformations - that is, ordinary functions - may also be inserted in the pipeline as shown in the following example (the classifier is probabilistic but the pipeline itself is deterministic):</p><pre><code class="language-none">@pipeline MyPipe(X -&gt; coerce(X, :age=&gt;Continuous),
                 hot=OneHotEncoder(),
                 cnst=ConstantClassifier(),
                 yhat -&gt; mode.(yhat))</code></pre><p><strong>Return value</strong></p><p>An instance of the new type, with default hyperparameters (see above), is returned.</p><p><strong>Target transformation and inverse transformation</strong></p><p>A learned target transformation (such as standardization) can also be specified, using the keyword <code>target</code>, provided the transformer provides an <code>inverse_transform</code> method:</p><pre><code class="language-none">@load KNNRegressor
@pipeline MyPipe(hot=OneHotEncoder(),
                 knn=KNNRegressor(),
                 target=UnivariateTransformer())</code></pre><p>A static transformation can be specified instead, but then an <code>inverse</code> must also be given:</p><pre><code class="language-none">@load KNNRegressor
@pipeline MyPipe(hot=OneHotEncoder(),
                 knn=KNNRegressor(),
                 target = v -&gt; log.(v),
                 inverse = v -&gt; exp.(v))</code></pre><p><em>Important.</em> While the supervised model in a pipeline providing a  target transformation can appear anywhere in the pipeline (as in  <code>ConstantClassifier</code> example above), the inverse operation is always  performed on the output of the <em>final</em> model or static  transformation in the pipeline.</p><p>See also: <a href="#MLJBase.@from_network-Tuple"><code>@from_network</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/pipelines.jl#LL265-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.StaticTransformer" href="#MLJBase.StaticTransformer"><code>MLJBase.StaticTransformer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Applies a given data transformation <code>f</code> (either a function or callable).</p><p><strong>Field</strong></p><ul><li><code>f=identity</code>: function or callable object to use for the data transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/77c11abfe3ea9f0361939af9f3079cf31984a7d2/src/composition/pipeline_static.jl#LL13-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../resampling/">« Resampling</a><a class="docs-footer-nextpage" href="../datasets/">Datasets »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 April 2020 04:13">Tuesday 28 April 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
