var documenterSearchIndex = {"docs":
[{"location":"openml/#OpenML-1","page":"OpenML","title":"OpenML","text":"","category":"section"},{"location":"openml/#","page":"OpenML","title":"OpenML","text":"Modules = [MLJBase, OpenML]\nPages   = [\"openml.jl\"]","category":"page"},{"location":"openml/#MLJBase.OpenML.convert_ARFF_to_rowtable-Tuple{Any}","page":"OpenML","title":"MLJBase.OpenML.convert_ARFF_to_rowtable","text":"Returns a Vector of NamedTuples. Receives an HTTP.Message.response that has an ARFF file format in the body of the Message.\n\n\n\n\n\n","category":"method"},{"location":"openml/#MLJBase.OpenML.load-Tuple{Int64}","page":"OpenML","title":"MLJBase.OpenML.load","text":"OpenML.load(id)\n\nLoad the OpenML dataset with specified id, from those listed on the OpenML site.\n\nReturns a \"row table\", i.e., a Vector of identically typed NamedTuples. A row table is compatible with the Tables.jl interface and can therefore be readily converted to other compatible formats. For example:\n\nusing DataFrames\nrowtable = OpenML.load(61);\ndf = DataFrame(rowtable);\ndf2 = coerce(df, :class=>Multiclass)\n\n\n\n\n\n","category":"method"},{"location":"openml/#MLJBase.OpenML.load_Data_Features-Tuple{Int64}","page":"OpenML","title":"MLJBase.OpenML.load_Data_Features","text":"Returns a list of all data qualities in the system.\n\n271 - Unknown dataset. Data set with the given data ID was not found (or is not shared with you).\n272 - No features found. The dataset did not contain any features, or we could not extract them.\n273 - Dataset not processed yet. The dataset was not processed yet, features are not yet available. Please wait for a few minutes.\n274 - Dataset processed with error. The feature extractor has run into an error while processing the dataset. Please check whether it is a valid supported file. If so, please contact the API admins.\n\n\n\n\n\n","category":"method"},{"location":"openml/#MLJBase.OpenML.load_Data_Qualities-Tuple{Int64}","page":"OpenML","title":"MLJBase.OpenML.load_Data_Qualities","text":"Returns the qualities of a dataset.\n\n360 - Please provide data set ID\n361 - Unknown dataset. The data set with the given ID was not found in the database, or is not shared with you.\n362 - No qualities found. The registered dataset did not contain any calculated qualities.\n363 - Dataset not processed yet. The dataset was not processed yet, no qualities are available. Please wait for a few minutes.\n364 - Dataset processed with error. The quality calculator has run into an error while processing the dataset. Please check whether it is a valid supported file. If so, contact the support team.\n365 - Interval start or end illegal. There was a problem with the interval start or end.\n\n\n\n\n\n","category":"method"},{"location":"openml/#MLJBase.OpenML.load_Data_Qualities_List-Tuple{}","page":"OpenML","title":"MLJBase.OpenML.load_Data_Qualities_List","text":"Returns a list of all data qualities in the system.\n\n412 - Precondition failed. An error code and message are returned\n370 - No data qualities available. There are no data qualities in the system.\n\n\n\n\n\n","category":"method"},{"location":"openml/#MLJBase.OpenML.load_Dataset_Description-Tuple{Int64}","page":"OpenML","title":"MLJBase.OpenML.load_Dataset_Description","text":"Returns information about a dataset. The information includes the name, information about the creator, URL to download it and more.\n\n110 - Please provide data_id.\n111 - Unknown dataset. Data set description with data_id was not found in the database.\n112 - No access granted. This dataset is not shared with you.\n\n\n\n\n\n","category":"method"},{"location":"openml/#MLJBase.OpenML.load_List_And_Filter-Tuple{String}","page":"OpenML","title":"MLJBase.OpenML.load_List_And_Filter","text":"List datasets, possibly filtered by a range of properties. Any number of properties can be combined by listing them one after the other in the form '/data/list/{filter}/{value}/{filter}/{value}/...' Returns an array with all datasets that match the constraints.\n\nAny combination of these filters /limit/{limit}/offset/{offset} - returns only {limit} results starting from result number {offset}. Useful for paginating results. With /limit/5/offset/10,     results 11..15 will be returned.\n\nBoth limit and offset need to be specified. /status/{status} - returns only datasets with a given status, either 'active', 'deactivated', or 'inpreparation'. /tag/{tag} - returns only datasets tagged with the given tag. /{dataquality}/{range} - returns only tasks for which the underlying datasets have certain qualities. {dataquality} can be dataid, dataname, dataversion, numberinstances, numberfeatures, numberclasses, numbermissingvalues. {range} can be a specific value or a range in the form 'low..high'. Multiple qualities can be combined, as in 'numberinstances/0..50/number_features/0..10'.\n\n370 - Illegal filter specified.\n371 - Filter values/ranges not properly specified.\n372 - No results. There where no matches for the given constraints.\n373 - Can not specify an offset without a limit.\n\n\n\n\n\n","category":"method"},{"location":"measures/#Measures-1","page":"Measures","title":"Measures","text":"","category":"section"},{"location":"measures/#Helper-functions-1","page":"Measures","title":"Helper functions","text":"","category":"section"},{"location":"measures/#","page":"Measures","title":"Measures","text":"Modules = [MLJBase]\nPages   = [\"measures/registry.jl\", \"measures/measures.jl\"]","category":"page"},{"location":"measures/#MLJBase.metadata_measure-Tuple{Any}","page":"Measures","title":"MLJBase.metadata_measure","text":"metadata_measure(T; kw...)\n\nHelper function to write the metadata for a single measure.\n\n\n\n\n\n","category":"method"},{"location":"measures/#Continuous-loss-functions-1","page":"Measures","title":"Continuous loss functions","text":"","category":"section"},{"location":"measures/#","page":"Measures","title":"Measures","text":"Modules = [MLJBase]\nPages   = [\"measures/continuous.jl\"]","category":"page"},{"location":"measures/#MLJBase.l1","page":"Measures","title":"MLJBase.l1","text":"l1(ŷ, y)\nl1(ŷ, y, w)\n\nL1 per-observation loss.\n\nFor more information, run info(l1).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.l2","page":"Measures","title":"MLJBase.l2","text":"l2(ŷ, y)\nl2(ŷ, y, w)\n\nL2 per-observation loss.\n\nFor more information, run info(l2).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.mae","page":"Measures","title":"MLJBase.mae","text":"mae(ŷ, y)\nmae(ŷ, y, w)\n\nMean absolute error.\n\ntextMAE =  n^-1ᵢyᵢ-ŷᵢ or textMAE = n^-1ᵢwᵢyᵢ-ŷᵢ\n\nFor more information, run info(mae).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.mape","page":"Measures","title":"MLJBase.mape","text":" MAPE(; tol=esp())\n\nMean Absolute Proportional Error:\n\ntextMAPE =  m^-1ᵢ(yᵢ-yᵢ) over yᵢ where the sum is over indices such that yᵢ > tol and m is the number of such indices.\n\nFor more information, run info(mape).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.rms","page":"Measures","title":"MLJBase.rms","text":"rms(ŷ, y)\nrms(ŷ, y, w)\n\nRoot mean squared error:\n\ntextRMS = sqrtn^-1ᵢyᵢ-yᵢ^2 or textRMS = sqrtfracᵢwᵢyᵢ-yᵢ^2ᵢwᵢ\n\nFor more information, run info(rms).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.rmsl","page":"Measures","title":"MLJBase.rmsl","text":"rmsl(ŷ, y)\n\nRoot mean squared logarithmic error:\n\ntextRMSL = n^-1ᵢlogleft(yᵢ over yᵢright)\n\nFor more information, run info(rmsl).\n\nSee also rmslp1.\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.rmslp1","page":"Measures","title":"MLJBase.rmslp1","text":"rmslp1(ŷ, y)\n\nRoot mean squared logarithmic error with an offset of 1:\n\ntextRMSLP1 = n^-1ᵢlogleft(yᵢ + 1 over yᵢ + 1right)\n\nFor more information, run info(rmslp1).\n\nSee also rmsl.\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.rmsp","page":"Measures","title":"MLJBase.rmsp","text":"rmsp(ŷ, y)\n\nRoot mean squared proportional loss:\n\ntextRMSP = m^-1ᵢ left(yᵢ-yᵢ over yᵢright)^2\n\nwhere the sum is over indices such that yᵢ≂̸0 and m is the number of such indices.\n\nFor more information, run info(rmsp).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#Confusion-matrix-1","page":"Measures","title":"Confusion matrix","text":"","category":"section"},{"location":"measures/#","page":"Measures","title":"Measures","text":"Modules = [MLJBase]\nPages   = [\"measures/confusion_matrix.jl\"]","category":"page"},{"location":"measures/#MLJBase.confusion_matrix-Tuple{AbstractArray{#s528,1} where #s528<:CategoricalArrays.CategoricalValue,AbstractArray{#s527,1} where #s527<:CategoricalArrays.CategoricalValue}","page":"Measures","title":"MLJBase.confusion_matrix","text":"confusion_matrix(ŷ, y; rev=false)\n\nComputes the confusion matrix given a predicted ŷ with categorical elements and the actual y. Rows are the predicted class, columns the ground truth. The ordering follows that of levels(y).\n\nKeywords\n\nrev=false: in the binary case, this keyword allows to swap the ordering of              classes.\nperm=[]:   in the general case, this keyword allows to specify a permutation              re-ordering the classes.\nwarn=true: whether to show a warning in case y does not have scientific              type OrderedFactor{2} (see note below).\n\nNote\n\nTo decrease the risk of unexpected errors, if y does not have scientific type OrderedFactor{2} (and so does not have a \"natural ordering\" negative-positive), a warning is shown indicating the current order unless the user explicitly specifies either rev or perm in which case it's assumed the user is aware of the class ordering.\n\nThe confusion_matrix is a measure (although neither a score nor a loss) and so may be specified as such in calls to evaluate, evaluate!, although not in TunedModels.  In this case, however, there no way to specify an ordering different from levels(y), where y is the target. \n\n\n\n\n\n","category":"method"},{"location":"measures/#MLJBase.ConfusionMatrix","page":"Measures","title":"MLJBase.ConfusionMatrix","text":"ConfusionMatrix{C}\n\nConfusion matrix with C ≥ 2 classes. Rows correspond to predicted values and columns to the ground truth.\n\n\n\n\n\n","category":"type"},{"location":"measures/#MLJBase.ConfusionMatrix-Tuple{Array{Int64,2},Array{String,1}}","page":"Measures","title":"MLJBase.ConfusionMatrix","text":"ConfusionMatrix(m, labels)\n\nInstantiates a confusion matrix out of a square integer matrix m. Rows are the predicted class, columns the ground truth. See also the wikipedia article.\n\n\n\n\n\n","category":"method"},{"location":"measures/#Finite-loss-functions-1","page":"Measures","title":"Finite loss functions","text":"","category":"section"},{"location":"measures/#","page":"Measures","title":"Measures","text":"Modules = [MLJBase]\nPages   = [\"measures/finite.jl\"]","category":"page"},{"location":"measures/#MLJBase.accuracy","page":"Measures","title":"MLJBase.accuracy","text":"accuracy\n\nClassification accuracy; aliases: accuracy.\n\naccuracy(ŷ, y)\naccuracy(ŷ, y, w)\naccuracy(conf_mat)\n\nReturns the accuracy of the (point) predictions ŷ, given true observations y, optionally weighted by the weights w. All three arguments must be abstract vectors of the same length. This metric is invariant to class labelling and can be used for multiclass classification.\n\nFor more information, run info(accuracy).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.area_under_curve","page":"Measures","title":"MLJBase.area_under_curve","text":"area_under_curve\n\nArea under the ROC curve; aliases: area_under_curve, auc\n\narea_under_curve(ŷ, y)\n\nReturn the area under the receiver operator characteristic (curve), for probabilistic predictions ŷ, given ground truth y. This metric is invariant to class labelling and can be used only for binary classification.\n\nFor more information, run info(area_under_curve).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.balanced_accuracy","page":"Measures","title":"MLJBase.balanced_accuracy","text":"balanced_accuracy\n\nBalanced classification accuracy; aliases: balanced_accuracy, bacc, bac.\n\nbalanced_accuracy(ŷ, y [, w])\nbalanced_accuracy(conf_mat)\n\nReturn the balanced accuracy of the point prediction ŷ, given true observations y, optionally weighted by w. The balanced accuracy takes into consideration class imbalance. All  three arguments must have the same length. This metric is invariant to class labelling and can be used for multiclass classification.\n\nFor more information, run info(balanced_accuracy).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.cross_entropy","page":"Measures","title":"MLJBase.cross_entropy","text":"cross_entropy\n\nCross entropy loss with probabilities clamped between eps() and 1-eps(); aliases: cross_entropy.\n\nce = CrossEntropy(; eps=eps())\nce(ŷ, y)\n\nGiven an abstract vector of distributions ŷ and an abstract vector of true observations y, return the corresponding cross-entropy loss (aka log loss) scores.\n\nSince the score is undefined in the case of the true observation has predicted probability zero, probablities are clipped between eps and 1-eps where eps can be specified.\n\nIf sᵢ is the predicted probability for the true class yᵢ then the score for that example is given by\n\n-log(clamp(sᵢ, eps, 1-eps))\n\nFor more information, run info(cross_entropy).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.false_discovery_rate","page":"Measures","title":"MLJBase.false_discovery_rate","text":"false_discovery_rate\n\nfalse discovery rate; aliases: false_discovery_rate, falsediscovery_rate, fdr.\n\nfalse_discovery_rate(ŷ, y)\n\nFalse discovery rate for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use FalseDiscoveryRate(rev=true) instead of false_discovery_rate.\n\nFor more information, run info(false_discovery_rate).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.false_negative","page":"Measures","title":"MLJBase.false_negative","text":"false_negative\n\nNumber of false negatives; aliases: false_negative, falsenegative.\n\nfalse_negative(ŷ, y)\n\nNumber of false positives for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use FalseNegative(rev=true) instead of false_negative.\n\nFor more information, run info(false_negative).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.false_negative_rate","page":"Measures","title":"MLJBase.false_negative_rate","text":"false_negative_rate\n\nfalse negative rate; aliases: false_negative_rate, falsenegative_rate, fnr, miss_rate.\n\nfalse_negative_rate(ŷ, y)\n\nFalse negative rate for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use FalseNegativeRate(rev=true) instead of false_negative_rate.\n\nFor more information, run info(false_negative_rate).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.false_positive","page":"Measures","title":"MLJBase.false_positive","text":"false_positive\n\nNumber of false positives; aliases: false_positive, falsepositive.\n\nfalse_positive(ŷ, y)\n\nNumber of false positives for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use FalsePositive(rev=true) instead of false_positive.\n\nFor more information, run info(false_positive).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.false_positive_rate","page":"Measures","title":"MLJBase.false_positive_rate","text":"false_positive_rate\n\nfalse positive rate; aliases: false_positive_rate, falsepositive_rate, fpr, fallout.\n\nfalse_positive_rate(ŷ, y)\n\nFalse positive rate for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use FalsePositiveRate(rev=true) instead of false_positive_rate.\n\nFor more information, run info(false_positive_rate).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.matthews_correlation","page":"Measures","title":"MLJBase.matthews_correlation","text":"matthews_correlation\n\nMatthew's correlation; aliases: matthews_correlation, mcc\n\nmatthews_correlation(ŷ, y)\nmatthews_correlation(conf_mat)\n\nReturn Matthews' correlation coefficient corresponding to the point prediction ŷ, given true observations y. This metric is invariant to class labelling and can be used for multiclass classification.\n\nFor more information, run info(matthews_correlation).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.misclassification_rate","page":"Measures","title":"MLJBase.misclassification_rate","text":"misclassification_rate\n\nmisclassification rate; aliases: misclassification_rate, mcr.\n\nmisclassification_rate(ŷ, y)\nmisclassification_rate(ŷ, y, w)\nmisclassification_rate(conf_mat)\n\nReturns the rate of misclassification of the (point) predictions ŷ, given true observations y, optionally weighted by the weights w. All three arguments must be abstract vectors of the same length. A confusion matrix can also be passed as argument. This metric is invariant to class labelling and can be used for multiclass classification.\n\nFor more information, run info(misclassification_rate).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.negative_predictive_value","page":"Measures","title":"MLJBase.negative_predictive_value","text":"negative_predictive_value\n\nnegative predictive value; aliases: negative_predictive_value, negativepredictive_value, npv.\n\nnegative_predictive_value(ŷ, y)\n\nNegative predictive value for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use NPV(rev=true) instead of negative_predictive_value.\n\nFor more information, run info(negative_predictive_value).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.positive_predictive_value","page":"Measures","title":"MLJBase.positive_predictive_value","text":"positive_predictive_value\n\npositive predictive value (aka precision); aliases: positive_predictive_value, ppv, Precision(), positivepredictive_value. \n\npositive_predictive_value(ŷ, y)\n\nPositive predictive value for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use Precision(rev=true) instead of positive_predictive_value.\n\nFor more information, run info(positive_predictive_value).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.true_negative","page":"Measures","title":"MLJBase.true_negative","text":"true_negative\n\nNumber of true negatives; aliases: true_negative, truenegative.\n\ntrue_negative(ŷ, y)\n\nNumber of true negatives for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use TrueNegative(rev=true) instead of true_negative.\n\nFor more information, run info(true_negative).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.true_negative_rate","page":"Measures","title":"MLJBase.true_negative_rate","text":"true_negative_rate\n\ntrue negative rate; aliases: true_negative_rate, truenegative_rate, tnr, specificity, selectivity.\n\ntrue_negative_rate(ŷ, y)\n\nTrue negative rate for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use TrueNegativeRate(rev=true) instead of true_negative_rate.\n\nFor more information, run info(true_negative_rate).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.true_positive","page":"Measures","title":"MLJBase.true_positive","text":"true_positive\n\nNumber of true positives; aliases: true_positive, truepositive.\n\ntrue_positive(ŷ, y)\n\nNumber of true positives for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use TruePositive(rev=true) instead of true_positive.\n\nFor more information, run info(true_positive).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.true_positive_rate","page":"Measures","title":"MLJBase.true_positive_rate","text":"true_positive_rate\n\nTrue positive rate; aliases: true_positive_rate, truepositive_rate, tpr, sensitivity, recall, hit_rate.\n\ntrue_positive_rate(ŷ, y)\n\nTrue positive rate for observations ŷ and ground truth y. Assigns false to first element of levels(y). To reverse roles, use TruePositiveRate(rev=true) instead of true_positive_rate.\n\nFor more information, run info(true_positive_rate).\n\n\n\n\n\n","category":"constant"},{"location":"measures/#MLJBase.BrierScore-Tuple{}","page":"Measures","title":"MLJBase.BrierScore","text":"BrierScore(; distribution=UnivariateFinite)(ŷ, y [, w])\n\nGiven an abstract vector of distributions ŷ of type distribution, and an abstract vector of true observations y, return the corresponding Brier (aka quadratic) scores. Weight the scores using w if provided.\n\nCurrently only distribution=UnivariateFinite is supported, which is applicable to superivised models with Finite target scitype. In this case, if p(y) is the predicted probability for a single observation y, and C all possible classes, then the corresponding Brier score for that observation is given by\n\n2p(y) - left(sum_η  C p(η)^2right) - 1\n\nNote that BrierScore()=BrierScore{UnivariateFinite} has the alias brier_score.\n\nWarning. Here BrierScore is a \"score\" in the sense that bigger is better (with 0 optimal, and all other values negative). In Brier's original 1950 paper, and many other places, it has the opposite sign, despite the name. Moreover, the present implementation does not treat the binary case as special, so that the score may differ, in that case, by a factor of two from usage elsewhere.\n\nFor more information, run info(BrierScore).\n\n\n\n\n\n","category":"method"},{"location":"measures/#MLJBase.FScore","page":"Measures","title":"MLJBase.FScore","text":"FScore{β}(rev=nothing)\n\nOne-parameter generalization, F_β, of the F-measure or balanced F-score.\n\nWikipedia entry\n\nFScore{β}(ŷ, y)\n\nEvaluate F_β score on observations ,ŷ, given ground truth values, y.\n\nBy default, the second element of levels(y) is designated as true. To reverse roles, use FScore{β}(rev=true) instead of FScore{β}.\n\nFor more information, run info(FScore).\n\n\n\n\n\n","category":"type"},{"location":"measures/#MLJBase.roc_curve-Tuple{AbstractArray{#s542,1} where #s542<:UnivariateFinite,AbstractArray{#s541,1} where #s541<:CategoricalArrays.CategoricalValue}","page":"Measures","title":"MLJBase.roc_curve","text":"fprs, tprs, ts = roc_curve(ŷ, y) = roc(ŷ, y)\n\nReturn the ROC curve for a two-class probabilistic prediction ŷ given the ground  truth y. The true positive rates, false positive rates over a range of thresholds ts are returned. Note that if there are k unique scores, there are correspondingly  k thresholds and k+1 \"bins\" over which the FPR and TPR are constant:\n\n[0.0 - thresh[1]]\n[thresh[1] - thresh[2]]\n...\n[thresh[k] - 1]\n\nconsequently, tprs and fprs are of length k+1 if ts is of length k.\n\nTo draw the curve using your favorite plotting backend, do plot(fprs, tprs).\n\n\n\n\n\n","category":"method"},{"location":"measures/#MLJBase._idx_unique_sorted-Tuple{AbstractArray{#s543,1} where #s543<:Real}","page":"Measures","title":"MLJBase._idx_unique_sorted","text":"_idx_unique_sorted(v)\n\nInternal function to return the index of unique elements in v under the assumption that the vector v is sorted in decreasing order.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions/#Univariate-Finite-Distribution-1","page":"Distributions","title":"Univariate Finite Distribution","text":"","category":"section"},{"location":"distributions/#","page":"Distributions","title":"Distributions","text":"Modules = [MLJBase]\nPages   = [\"interface/univariate_finite.jl\"]","category":"page"},{"location":"distributions/#hyperparameters-1","page":"Distributions","title":"hyperparameters","text":"","category":"section"},{"location":"distributions/#","page":"Distributions","title":"Distributions","text":"Modules = [MLJBase]\nPages   = [\"hyperparam/one_dimensional_range_methods.jl\", \"hyperparam/one_dimensional_ranges.jl\"]","category":"page"},{"location":"distributions/#Distributions.sampler-Union{Tuple{T}, Tuple{NumericRange{T,B,D} where D where B<:MLJBase.Boundedness,Distributions.Distribution{Distributions.Univariate,S} where S<:Distributions.ValueSupport}} where T","page":"Distributions","title":"Distributions.sampler","text":"sampler(r::NominalRange, probs::AbstractVector{<:Real})\nsampler(r::NominalRange)\nsampler(r::NumericRange{T}, d)\n\nConstruct an object s which can be used to generate random samples from a ParamRange object r (a one-dimensional range) using one of the following calls:\n\nrand(s)             # for one sample\nrand(s, n)          # for n samples\nrand(rng, s [, n])  # to specify an RNG\n\nThe argument probs can be any probability vector with the same length as r.values. The second sampler method above calls the first with a uniform probs vector.\n\nThe argument d can be either an arbitrary instance of UnivariateDistribution from the Distributions.jl package, or one of a Distributions.jl types for which fit(d, ::NumericRange) is defined. These include: Arcsine, Uniform, Biweight, Cosine, Epanechnikov, SymTriangularDist, Triweight, Normal, Gamma, InverseGaussian, Logistic, LogNormal, Cauchy, Gumbel, Laplace, and Poisson; but see the doc-string for Distributions.fit for an up-to-date list.\n\nIf d is an instance, then sampling is from a truncated form of the supplied distribution d, the truncation bounds being r.lower and r.upper (the attributes r.origin and r.unit attributes are ignored). For discrete numeric ranges (T <: Integer) the samples are rounded.\n\nIf d is a type then a suitably truncated distribution is automatically generated using Distributions.fit(d, r).\n\nImportant. Values are generated with no regard to r.scale, except in the special case r.scale is a callable object f. In that case, f is applied to all values generated by rand as described above (prior to rounding, in the case of discrete numeric ranges).\n\nExamples\n\nr = range(Char, :letter, values=collect(\"abc\"))\ns = sampler(r, [0.1, 0.2, 0.7])\nsamples =  rand(s, 1000);\nStatsBase.countmap(samples)\nDict{Char,Int64} with 3 entries:\n  'a' => 107\n  'b' => 205\n  'c' => 688\n\nr = range(Int, :k, lower=2, upper=6) # numeric but discrete\ns = sampler(r, Normal)\nsamples = rand(s, 1000);\nUnicodePlots.histogram(samples)\n           ┌                                        ┐\n[2.0, 2.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 119\n[2.5, 3.0) ┤ 0\n[3.0, 3.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 296\n[3.5, 4.0) ┤ 0\n[4.0, 4.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 275\n[4.5, 5.0) ┤ 0\n[5.0, 5.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 221\n[5.5, 6.0) ┤ 0\n[6.0, 6.5) ┤▇▇▇▇▇▇▇▇▇▇▇ 89\n           └                                        ┘\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MLJBase.iterator-Tuple{Random.AbstractRNG,ParamRange,Vararg{Any,N} where N}","page":"Distributions","title":"MLJBase.iterator","text":"iterator([rng, ], r::NominalRange, [,n])\niterator([rng, ], r::NumericRange, n)\n\nReturn an iterator (currently a vector) for a ParamRange object r. In the first case iteration is over all values stored in the range (or just the first n, if n is specified). In the second case, the iteration is over approximately n ordered values, generated as follows:\n\n(i) First, exactly n values are generated between U and L, with a spacing determined by r.scale (uniform if scale=:linear) where U and L are given by the following table:\n\nr.lower r.upper L U\nfinite finite r.lower r.upper\n-Inf finite r.upper - 2r.unit r.upper\nfinite Inf r.lower r.lower + 2r.unit\n-Inf Inf r.origin - r.unit r.origin + r.unit\n\n(ii) If a callable f is provided as scale, then a uniform spacing is always applied in (i) but f is broadcast over the results. (Unlike ordinary scales, this alters the effective range of values generated, instead of just altering the spacing.)\n\n(iii) If r is a discrete numeric range (r isa NumericRange{<:Integer}) then the values are additionally rounded, with any duplicate values removed. Otherwise all the values are used (and there are exacltly n of them).\n\n(iv) Finally, if a random number generator rng is specified, then the values are returned in random order (sampling without replacement), and otherwise they are returned in numeric order, or in the order provided to the range constructor, in the case of a NominalRange.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#MLJBase.scale-Tuple{NominalRange}","page":"Distributions","title":"MLJBase.scale","text":"scale(r::ParamRange)\n\nReturn the scale associated with a ParamRange object r. The possible return values are: :none (for a NominalRange), :linear, :log, :log10, :log2, or :custom (if r.scale is a callable object).\n\n\n\n\n\n","category":"method"},{"location":"distributions/#StatsBase.fit-Union{Tuple{D}, Tuple{Type{D},NumericRange}} where D<:Distributions.Distribution","page":"Distributions","title":"StatsBase.fit","text":"Distributions.fit(D, r::MLJBase.NumericRange)\n\nFit and return a distribution d of type D to the one-dimensional range r.\n\nOnly types D in the table below are supported.\n\nThe distribution d is constructed in two stages. First, a distributon d0, characterized by the conditions in the second column of the table, is fit to r. Then d0 is truncated between r.lower and r.upper to obtain d.\n\nDistribution type D Characterization of d0\nArcsine, Uniform, Biweight, Cosine, Epanechnikov, SymTriangularDist, Triweight minimum(d) = r.lower, maximum(d) = r.upper\nNormal, Gamma, InverseGaussian, Logistic, LogNormal mean(d) = r.origin, std(d) = r.unit\nCauchy, Gumbel, Laplace, (Normal) Dist.location(d) = r.origin, Dist.scale(d)  = r.unit\nPoisson Dist.mean(d) = r.unit\n\nHere Dist = Distributions.\n\n\n\n\n\n","category":"method"},{"location":"distributions/#Base.range-Union{Tuple{D}, Tuple{Union{Model, Type},Union{Expr, Symbol}}} where D","page":"Distributions","title":"Base.range","text":"r = range(model, :hyper; values=nothing)\n\nDefine a one-dimensional NominalRange object for a field hyper of model. Note that r is not directly iterable but iterator(r) is. \n\nBy default, the behaviour of range methods depends on the type of the value of the hyperparameter :hyper at model during range construction. \n\nTo override this behaviour (for instance if model is not available) specify a type in place of model so the behaviour depends on the value of the specified type.\n\nA nested hyperparameter is specified using dot notation. For example, :(atom.max_depth) specifies the max_depth hyperparameter of the submodel model.atom.\n\nr = range(model, :hyper; upper=nothing, lower=nothing,\n          scale=nothing, values=nothing)\n\nAssuming values is not specified, defines a one-dimensional NumericRange object for a Real field hyper of model.  Note that r is not directly iteratable but iterator(r, n)is an iterator of length n. To generate random elements from r, instead apply rand methods to sampler(r). The supported scales are :linear,:log, :logminus, :log10, :log2, or a callable object.\n\nA nested hyperparameter is specified using dot notation (see above).\n\nIf scale is unspecified, it is set to :linear, :log, :logminus, or :linear, according to whether the interval (lower, upper) is bounded, right-unbounded, left-unbounded, or doubly unbounded, respectively.  Note upper=Inf and lower=-Inf are allowed.\n\nIf values is specified, the other keyword arguments are ignored and a NominalRange object is returned (see above).\n\nSee also: iterator, sampler\n\n\n\n\n\n","category":"method"},{"location":"distributions/#Utility-functions-1","page":"Distributions","title":"Utility functions","text":"","category":"section"},{"location":"distributions/#","page":"Distributions","title":"Distributions","text":"Modules = [MLJBase]\nPages   = [\"distributions.jl\"]","category":"page"},{"location":"utilities/#Utilities-1","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#Machines-1","page":"Utilities","title":"Machines","text":"","category":"section"},{"location":"utilities/#","page":"Utilities","title":"Utilities","text":"Modules = [MLJBase]\nPages   = [\"machines.jl\"]","category":"page"},{"location":"utilities/#MLJBase.fit_only!-Tuple{Machine}","page":"Utilities","title":"MLJBase.fit_only!","text":"MLJBase.fit_only!(mach::Machine; rows=nothing, verbosity=1, force=false)\n\nWithout mutating any other machine on which it may depend, perform one of the following actions to the machine mach, using the data and model bound to it, and restricting the data to rows if specified:\n\nAb initio training. Ignoring any previous learned parameters and cache, compute and store new learned parameters. Increment mach.state.\nTraining update. Making use of previous learned parameters and/or  cache, replace or mutate existing learned parameters. The effect is  the same (or nearly the same) as in ab initio training, but may be  faster or use less memory, assuming the model supports an update  option (implements MLJBase.update). Increment mach.state.\nNo-operation. Leave existing learned parameters untouched. Do not  increment mach.state.\n\nTraining action logic\n\nFor the action to be a no-operation, either mach.frozen == true or none of the following apply:\n\n(i) mach has never been trained (mach.state == 0).\n(ii) force == true\n(iii) The state of some other machine on which mach depends has changed since the last time mach was trained (ie, the last time mach.state was last incremented)\n(iv) The specified rows have changed since the last retraining.\n(v) mach.model has changed since the last retraining.\n\nIn cases (i) - (iv), mach is trained ab initio. In case (v) a training update is applied.\n\nTo freeze or unfreeze mach, use freeze!(mach) or thaw!(mach).\n\nImplementation detail\n\nThe data to which a machine is bound is stored in mach.args. Each element of args is either a Node object, or, in the case that concrete data was bound to the machine, it is concrete data wrapped in a Source node. In all cases, to obtain concrete data for actual training, each argument N is called, as in N() or N(rows=rows), and either MLJBase.fit (ab initio training) or MLJBase.update (training update) is dispatched on mach.model and this data. See the \"Adding models for general use\" section of the MLJ documentation for more on these lower-level training methods.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.freeze!-Tuple{Machine}","page":"Utilities","title":"MLJBase.freeze!","text":"freeze!(mach)\n\nFreeze the machine mach so that it will never be retrained (unless thawed).\n\nSee also thaw!.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.glb-Tuple{Machine{#s239} where #s239<:Union{DeterministicSurrogate, IntervalSurrogate, JointProbabilisticSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate, DeterministicComposite, IntervalComposite, JointProbabilisticComposite, ProbabilisticComposite, StaticComposite, UnsupervisedComposite}}","page":"Utilities","title":"MLJBase.glb","text":"N = glb(mach::Machine{<:Surrogate})\n\nA greatest lower bound for the nodes appearing in the signature of mach.\n\nPrivate method.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.machine","page":"Utilities","title":"MLJBase.machine","text":"machine(model, args...)\n\nConstruct a Machine object binding a model, storing hyper-parameters of some machine learning algorithm, to some data, args. When building a learning network, Node objects can be substituted for concrete data.\n\nmachine(Xs; oper1=node1, oper2=node2, ...)\nmachine(Xs, ys; oper1=node1, oper2=node2, ...)\nmachine(Xs, ys, ws; oper1=node1, oper2=node2, ...)\n\nConstruct a special machine called a learning network machine, that \"wraps\" a learning network, usually in preparation to export the network as a stand-alone composite model type. The keyword arguments declare what nodes are called when operations, such as predict and transform, are called on the machine.\n\nIn addition to the operations named in the constructor, the methods fit!, report, and fitted_params can be applied as usual to the machine constructed.\n\nmachine(Probablistic(), args...; kwargs...)\nmachine(Deterministic(), args...; kwargs...)\nmachine(Unsupervised(), args...; kwargs...)\nmachine(Static(), args...; kwargs...)\n\nSame as above, but specifying explicitly the kind of model the learning network is to meant to represent.\n\nLearning network machines are not to be confused with an ordinary machine that happens to be bound to a stand-alone composite model (i.e., an exported learning network).\n\nExamples\n\nSupposing a supervised learning network's final predictions are obtained by calling a node yhat, then the code\n\nmach = machine(Deterministic(), Xs, ys; predict=yhat)\nfit!(mach; rows=train)\npredictions = predict(mach, Xnew) # `Xnew` concrete data\n\nis  equivalent to\n\nfit!(yhat, rows=train)\npredictions = yhat(Xnew)\n\nHere Xs and ys are the source nodes receiving, respectively, the input and target data.\n\nIn a unsupervised learning network for clustering, with single source node Xs for inputs, and in which the node Xout delivers the output of dimension reduction, and yhat the class labels, one can write\n\nmach = machine(Unsupervised(), Xs; transform=Xout, predict=yhat)\nfit!(mach)\ntransformed = transform(mach, Xnew) # `Xnew` concrete data\npredictions = predict(mach, Xnew)\n\nwhich is equivalent to\n\nfit!(Xout)\nfit!(yhat)\ntransformed = Xout(Xnew)\npredictions = yhat(Xnew)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MLJBase.report-Tuple{Machine}","page":"Utilities","title":"MLJBase.report","text":"report(mach)\n\nReturn the report for a machine mach that has been fit!, for example the coefficients in a linear model.\n\nThis is a named tuple and human-readable if possible.\n\nIf mach is a machine for a composite model, such as a model constructed using @pipeline, then the returned named tuple has the composite type's field names as keys. The corresponding value is the report for the machine in the underlying learning network bound to that model. (If multiple machines share the same model, then the value is a vector.)\n\nusing MLJ\n@load LinearBinaryClassifier pkg=GLM\nX, y = @load_crabs;\npipe = @pipeline Standardizer LinearBinaryClassifier\nmach = machine(pipe, X, y) |> fit!\n\njulia> report(mach).linear_binary_classifier\n(deviance = 3.8893386087844543e-7,\n dof_residual = 195.0,\n stderror = [18954.83496713119, 6502.845740757159, 48484.240246060406, 34971.131004997274, 20654.82322484894, 2111.1294584763386],\n vcov = [3.592857686311793e8 9.122732393971942e6 … -8.454645589364915e7 5.38856837634321e6; 9.122732393971942e6 4.228700272808351e7 … -4.978433790526467e7 -8.442545425533723e6; … ; -8.454645589364915e7 -4.978433790526467e7 … 4.2662172244975924e8 2.1799125705781363e7; 5.38856837634321e6 -8.442545425533723e6 … 2.1799125705781363e7 4.456867590446599e6],)\n\n\nAdditional keys, machines and report_given_machine, give a list of all machines in the underlying network, and a dictionary of reports keyed on those machines.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.return!-Tuple{Machine{#s239} where #s239<:Union{DeterministicSurrogate, IntervalSurrogate, JointProbabilisticSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate},Union{Nothing, Model},Any}","page":"Utilities","title":"MLJBase.return!","text":"return!(mach::Machine{<:Surrogate}, model, verbosity)\n\nThe last call in custom code defining the MLJBase.fit method for a new composite model type. Here model is the instance of the new type appearing in the MLJBase.fit signature, while mach is a learning network machine constructed using model. Not relevant when defining composite models using @pipeline or @from_network.\n\nFor usage, see the example given below. Specificlly, the call does the following:\n\nDetermines which fields of model point to model instances in the learning network wrapped by mach, for recording in an object called cache, for passing onto the MLJ logic that handles smart updating (namely, an MLJBase.update fallback for composite models).\n\nCalls fit!(mach, verbosity=verbosity).\nMoves any data in sources nodes of the learning network into cache (for data-anonymization purposes).\nRecords a copy of model in cache.\nReturns cache and outcomes of training in an appropriate form (specifically, (mach.fitresult, cache, mach.report); see Adding Models for General Use for technical details.)\n\nExample\n\nThe following code defines, \"by hand\", a new model type MyComposite for composing standardization (whitening) with a deterministic regressor:\n\nmutable struct MyComposite <: DeterministicComposite\n    regressor\nend\n\nfunction MLJBase.fit(model::MyComposite, verbosity, X, y)\n    Xs = source(X)\n    ys = source(y)\n\n    mach1 = machine(Standardizer(), Xs)\n    Xwhite = transform(mach1, Xs)\n\n    mach2 = machine(model.regressor, Xwhite, ys)\n    yhat = predict(mach2, Xwhite)\n\n    mach = machine(Deterministic(), Xs, ys; predict=yhat)\n    return!(mach, model, verbosity)\nend\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.thaw!-Tuple{Machine}","page":"Utilities","title":"MLJBase.thaw!","text":"thaw!(mach)\n\nUnfreeze the machine mach so that it can be retrained.\n\nSee also freeze!.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJModelInterface.fitted_params-Tuple{Machine}","page":"Utilities","title":"MLJModelInterface.fitted_params","text":"fitted_params(mach)\n\nReturn the learned parameters for a machine mach that has been fit!, for example the coefficients in a linear model.\n\nThis is a named tuple and human-readable if possible.\n\nIf mach is a machine for a composite model, such as a model constructed using @pipeline, then the returned named tuple has the composite type's field names as keys. The corresponding value is the fitted parameters for the machine in the underlying learning network bound to that model. (If multiple machines share the same model, then the value is a vector.)\n\nusing MLJ\n@load LogisticClassifier pkg=MLJLinearModels\nX, y = @load_crabs;\npipe = @pipeline Standardizer LogisticClassifier\nmach = machine(pipe, X, y) |> fit!\n\njulia> fitted_params(mach).logistic_classifier\n(classes = CategoricalArrays.CategoricalValue{String,UInt32}[\"B\", \"O\"],\n coefs = Pair{Symbol,Float64}[:FL => 3.7095037897680405, :RW => 0.1135739140854546, :CL => -1.6036892745322038, :CW => -4.415667573486482, :BD => 3.238476051092471],\n intercept = 0.0883301599726305,)\n\nAdditional keys, machines and fitted_params_given_machine, give a list of all machines in the underlying network, and a dictionary of fitted parameters keyed on those machines.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"utilities/#StatsBase.fit!-Tuple{Machine{#s40} where #s40<:Union{DeterministicSurrogate, IntervalSurrogate, JointProbabilisticSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate}}","page":"Utilities","title":"StatsBase.fit!","text":"fit!(mach::Machine{<:Surrogate};\n     rows=nothing,\n     acceleration=CPU1(),\n     verbosity=1,\n     force=false))\n\nTrain the complete learning network wrapped by the machine mach.\n\nMore precisely, if s is the learning network signature used to construct mach, then call fit!(N), where N = glb(values(s)...) is a greatest lower bound on the nodes appearing in the signature. For example, if s = (predict=yhat, transform=W), then call fit!(glb(yhat, W)). Here glb is tuple overloaded for nodes.\n\nSee also machine\n\n\n\n\n\n","category":"method"},{"location":"utilities/#StatsBase.fit!-Tuple{Machine}","page":"Utilities","title":"StatsBase.fit!","text":"fit!(mach::Machine, rows=nothing, verbosity=1, force=false)\n\nFit the machine mach. In the case that mach has Node arguments, first train all other machines on which mach depends.\n\nTo attempt to fit a machine without touching any other machine, use fit_only!. For more on the internal logic of fitting see fit_only!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Base.replace-Tuple{Machine{#s39} where #s39<:Union{DeterministicSurrogate, IntervalSurrogate, JointProbabilisticSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate},Vararg{Pair,N} where N}","page":"Utilities","title":"Base.replace","text":"replace(mach, a1=>b1, a2=>b2, ...; empty_unspecified_sources=false)\n\nCreate a deep copy of a learning network machine mach but replacing any specified sources and models a1, a2, ... of the original underlying network with b1, b2, ....\n\nIf empty_unspecified_sources=true then any source nodes not specified are replaced with empty source nodes.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.ancestors-Tuple{Machine}","page":"Utilities","title":"MLJBase.ancestors","text":"ancestors(mach::Machine; self=false)\n\nAll ancestors of mach, including mach if self=true.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.model_supertype-Tuple{Any}","page":"Utilities","title":"MLJBase.model_supertype","text":"model_supertype(signature)\n\nReturn, if this can be deduced, which of Deterministic, Probabilistic and Unsupervised is the appropriate supertype for a composite model obtained by exporting a learning network with the specified signature.\n\nA learning network signature is a named tuple, such as (predict=yhat, transfrom=W), specifying what nodes of the network are called to produce output of each operation represented by the keys, in an exported version of the network.\n\nIf a supertype cannot be deduced, nothing is returned.\n\nIf the network with given signature is not exportable, this method will not error but it will not a give meaningful return value either.\n\nPrivate method.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJModelInterface.save-Tuple{Any,Machine}","page":"Utilities","title":"MLJModelInterface.save","text":"MLJ.save(filename, mach::Machine; kwargs...)\nMLJ.save(io, mach::Machine; kwargs...)\n\nMLJBase.save(filename, mach::Machine; kwargs...)\nMLJBase.save(io, mach::Machine; kwargs...)\n\nSerialize the machine mach to a file with path filename, or to an input/output stream io (at least IOBuffer instances are supported).\n\nThe format is JLSO (a wrapper for julia native or BSON serialization) unless a custom format has been implemented for the model type of mach.model. The keyword arguments kwargs are passed to the format-specific serializer, which in the JSLO case include these:\n\nkeyword values default\nformat :julia_serialize, :BSON :julia_serialize\ncompression :gzip, :none :none\n\nSee (see https://github.com/invenia/JLSO.jl for details.\n\nMachines are de-serialized using the machine constructor as shown in the example below. Data (or nodes) may be optionally passed to the constructor for retraining on new data using the saved model.\n\nExample\n\nusing MLJ\ntree = @load DecisionTreeClassifier\nX, y = @load_iris\nmach = fit!(machine(tree, X, y))\n\nMLJ.save(\"tree.jlso\", mach, compression=:none)\nmach_predict_only = machine(\"tree.jlso\")\npredict(mach_predict_only, X)\n\nmach2 = machine(\"tree.jlso\", selectrows(X, 1:100), y[1:100])\npredict(mach2, X) # same as above\n\nfit!(mach2) # saved learned parameters are over-written\npredict(mach2, X) # not same as above\n\n# using a buffer:\nio = IOBuffer()\nMLJ.save(io, mach)\nseekstart(io)\npredict_only_mach = machine(io)\npredict(predict_only_mach, X)\n\nwarning: Only load files from trusted sources\nMaliciously constructed JLSO files, like pickles, and most other general purpose serialization formats, can allow for arbitrary code execution during loading. This means it is possible for someone to use a JLSO file that looks like a serialized MLJ machine as a Trojan horse.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Parameter-Inspection-1","page":"Utilities","title":"Parameter Inspection","text":"","category":"section"},{"location":"utilities/#","page":"Utilities","title":"Utilities","text":"Modules = [MLJBase]\nPages   = [\"parameter_inspection.jl\"]","category":"page"},{"location":"utilities/#Show-1","page":"Utilities","title":"Show","text":"","category":"section"},{"location":"utilities/#","page":"Utilities","title":"Utilities","text":"Modules = [MLJBase]\nPages   = [\"show.jl\"]","category":"page"},{"location":"utilities/#MLJBase.color_off-Tuple{}","page":"Utilities","title":"MLJBase.color_off","text":"color_off()\n\nSuppress color and bold output at the REPL for displaying MLJ objects.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.color_on-Tuple{}","page":"Utilities","title":"MLJBase.color_on","text":"color_on()\n\nEnable color and bold output at the REPL, for enhanced display of MLJ objects.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.@constant-Tuple{Any}","page":"Utilities","title":"MLJBase.@constant","text":"@constant x = value\n\nEquivalent to const x = value but registers the binding thus:\n\nMLJBase.HANDLE_GIVEN_ID[objectid(value)] = :x\n\nRegistered objects get displayed using the variable name to which it was bound in calls to show(x), etc.\n\nWARNING: As with any const declaration, binding x to new value of the same type is not prevented and the registration will not be updated.\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#MLJBase.@more-Tuple{}","page":"Utilities","title":"MLJBase.@more","text":"@more\n\nEntered at the REPL, equivalent to show(ans, 100). Use to get a recursive description of all fields of the last REPL value.\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#MLJBase._recursive_show-Tuple{IO,MLJType,Any,Any}","page":"Utilities","title":"MLJBase._recursive_show","text":"_recursive_show(stream, object, current_depth, depth)\n\nGenerate a table of the field values of the MLJType object, dislaying each value by calling the method _show on it. The behaviour of _show(stream, f) is as follows:\n\nIf f is itself a MLJType object, then its short form is shown\n\nand _recursive_show generates as separate table for each of its field values (and so on, up to a depth of argument depth).\n\nOtherwise f is displayed as \"(omitted T)\" where T = typeof(f),\n\nunless istoobig(f) is false (the istoobig fall-back for arbitrary types being true). In the latter case, the long (ie, MIME\"plain/text\") form of f is shown. To override this behaviour, overload the _show method for the type in question.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.abbreviated-Tuple{Any}","page":"Utilities","title":"MLJBase.abbreviated","text":"to display abbreviated versions of integers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.handle-Tuple{Any}","page":"Utilities","title":"MLJBase.handle","text":"return abbreviated object id (as string) or it's registered handle (as string) if this exists\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utility-functions-1","page":"Utilities","title":"Utility functions","text":"","category":"section"},{"location":"utilities/#","page":"Utilities","title":"Utilities","text":"Modules = [MLJBase]\nPages   = [\"utilities.jl\"]","category":"page"},{"location":"utilities/#MLJBase.flat_values-Tuple{NamedTuple}","page":"Utilities","title":"MLJBase.flat_values","text":"flat_values(t::NamedTuple)\n\nView a nested named tuple t as a tree and return, as a tuple, the values at the leaves, in the order they appear in the original tuple.\n\njulia> t = (X = (x = 1, y = 2), Y = 3)\njulia> flat_values(t)\n(1, 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.recursive_getproperty-Tuple{Any,Symbol}","page":"Utilities","title":"MLJBase.recursive_getproperty","text":"recursive_getproperty(object, nested_name::Expr)\n\nCall getproperty recursively on object to extract the value of some nested property, as in the following example:\n\njulia> object = (X = (x = 1, y = 2), Y = 3)\njulia> recursive_getproperty(object, :(X.y))\n2\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.recursive_setproperty!-Tuple{Any,Symbol,Any}","page":"Utilities","title":"MLJBase.recursive_setproperty!","text":"recursively_setproperty!(object, nested_name::Expr, value)\n\nSet a nested property of an object to value, as in the following example:\n\njulia> mutable struct Foo\n           X\n           Y\n       end\n\njulia> mutable struct Bar\n           x\n           y\n       end\n\njulia> object = Foo(Bar(1, 2), 3)\nFoo(Bar(1, 2), 3)\n\njulia> recursively_setproperty!(object, :(X.y), 42)\n42\n\njulia> object\nFoo(Bar(1, 42), 3)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.unwind-Tuple","page":"Utilities","title":"MLJBase.unwind","text":"unwind(iterators...)\n\nRepresent all possible combinations of values generated by iterators as rows of a matrix A. In more detail, A has one column for each iterator in iterators and one row for each distinct possible combination of values taken on by the iterators. Elements in the first column cycle fastest, those in the last clolumn slowest.\n\nExample\n\njulia> iterators = ([1, 2], [\"a\",\"b\"], [\"x\", \"y\", \"z\"]);\njulia> MLJTuning.unwind(iterators...)\n12×3 Array{Any,2}:\n 1  \"a\"  \"x\"\n 2  \"a\"  \"x\"\n 1  \"b\"  \"x\"\n 2  \"b\"  \"x\"\n 1  \"a\"  \"y\"\n 2  \"a\"  \"y\"\n 1  \"b\"  \"y\"\n 2  \"b\"  \"y\"\n 1  \"a\"  \"z\"\n 2  \"a\"  \"z\"\n 1  \"b\"  \"z\"\n 2  \"b\"  \"z\"\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase._permute_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Array{Int64,1}}","page":"Utilities","title":"MLJBase._permute_rows","text":"permuterows(obj, perm)\n\nInternal function to return a vector or matrix with permuted rows given the permutation perm.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.available_name-Tuple{Any,Any}","page":"Utilities","title":"MLJBase.available_name","text":"available_name(modl::Module, name::Symbol)\n\nFunction to replace, if necessary, a given name with a modified one that ensures it is not the name of any existing object in the global scope of modl. Modifications are created with numerical suffixes.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.check_dimensions-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}","page":"Utilities","title":"MLJBase.check_dimensions","text":"check_dimension(X, Y)\n\nCheck that two vectors or matrices have matching dimensions\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.chunks-Tuple{AbstractRange,Integer}","page":"Utilities","title":"MLJBase.chunks","text":"chunks(range, n)\n\nSplit an AbstractRange  into n subranges of approximately equal length.\n\nExample\n\njulia> collect(chunks(1:5, 2))\n2-element Array{UnitRange{Int64},1}:\n 1:3\n 4:5\n\n**Private method**\n\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MLJBase.shuffle_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}","page":"Utilities","title":"MLJBase.shuffle_rows","text":"shuffle_rows(X, Y, ...; rng=)\n\nReturn a shuffled view of a vector or  matrix X (or set of such) using a random permutation (which can be seeded specifying rng).\n\n\n\n\n\n","category":"method"},{"location":"resampling/#Resampling-1","page":"Resampling","title":"Resampling","text":"","category":"section"},{"location":"resampling/#","page":"Resampling","title":"Resampling","text":"Modules = [MLJBase]\nPages   = [\"resampling.jl\"]","category":"page"},{"location":"resampling/#MLJBase.CV","page":"Resampling","title":"MLJBase.CV","text":"cv = CV(; nfolds=6,  shuffle=nothing, rng=nothing)\n\nCross-validation resampling strategy, for use in evaluate!, evaluate and tuning.\n\ntrain_test_pairs(cv, rows)\n\nReturns an nfolds-length iterator of (train, test) pairs of vectors (row indices), where each train and test is a sub-vector of rows. The test vectors are mutually exclusive and exhaust rows. Each train vector is the complement of the corresponding test vector. With no row pre-shuffling, the order of rows is preserved, in the sense that rows coincides precisely with the concatenation of the test vectors, in the order they are generated. The first r test vectors have length n + 1, where n, r = divrem(length(rows), nfolds), and the remaining test vectors have length n.\n\nPre-shuffling of rows is controlled by rng and shuffle. If rng is an integer, then the CV keyword constructor resets it to MersenneTwister(rng). Otherwise some AbstractRNG object is expected.\n\nIf rng is left unspecified, rng is reset to Random.GLOBAL_RNG, in which case rows are only pre-shuffled if shuffle=true is explicitly specified.\n\n\n\n\n\n","category":"type"},{"location":"resampling/#MLJBase.Holdout","page":"Resampling","title":"MLJBase.Holdout","text":"holdout = Holdout(; fraction_train=0.7,\n                     shuffle=nothing,\n                     rng=nothing)\n\nHoldout resampling strategy, for use in evaluate!, evaluate and in tuning.\n\ntrain_test_pairs(holdout, rows)\n\nReturns the pair [(train, test)], where train and test are vectors such that rows=vcat(train, test) and length(train)/length(rows) is approximatey equal to fraction_train`.\n\nPre-shuffling of rows is controlled by rng and shuffle. If rng is an integer, then the Holdout keyword constructor resets it to MersenneTwister(rng). Otherwise some AbstractRNG object is expected.\n\nIf rng is left unspecified, rng is reset to Random.GLOBAL_RNG, in which case rows are only pre-shuffled if shuffle=true is specified.\n\n\n\n\n\n","category":"type"},{"location":"resampling/#MLJBase.Resampler","page":"Resampling","title":"MLJBase.Resampler","text":"resampler = Resampler(model=ConstantRegressor(),\n                      resampling=CV(),\n                      measure=nothing,\n                      weights=nothing,\n                      operation=predict,\n                      repeats = 1,\n                      acceleration=default_resource(),\n                      check_measure=true)\n\nResampling model wrapper, used internally by the fit method of TunedModel instances. See `evaluate! for options. Not intended for general use.\n\nGiven a machine mach = machine(resampler, args...) one obtains a performance evaluation of the specified model, performed according to the prescribed resampling strategy and other parameters, using data args..., by calling fit!(mach) followed by evaluate(mach). The advantage over using evaluate(model, X, y) is that the latter call always calls fit on the model but fit!(mach) only calls update after the first call.\n\nThe sample weights are passed to the specified performance measures that support weights for evaluation.\n\n\n\n\n\n","category":"type"},{"location":"resampling/#MLJBase.StratifiedCV","page":"Resampling","title":"MLJBase.StratifiedCV","text":"stratified_cv = StratifiedCV(; nfolds=6,\n                               shuffle=false,\n                               rng=Random.GLOBAL_RNG)\n\nStratified cross-validation resampling strategy, for use in evaluate!, evaluate and in tuning. Applies only to classification problems (OrderedFactor or Multiclass targets).\n\ntrain_test_pairs(stratified_cv, rows, y)\n\nReturns an nfolds-length iterator of (train, test) pairs of vectors (row indices) where each train and test is a sub-vector of rows. The test vectors are mutually exclusive and exhaust rows. Each train vector is the complement of the corresponding test vector.\n\nUnlike regular cross-validation, the distribution of the levels of the target y corresponding to each train and test is constrained, as far as possible, to replicate that of y[rows] as a whole.\n\nThe stratified train_test_pairs algorithm is invariant to label renaming. For example, if you run replace!(y, 'a' => 'b', 'b' => 'a') and then re-run train_test_pairs, the returned (train, test) pairs will be the same.\n\nPre-shuffling of rows is controlled by rng and shuffle. If rng is an integer, then the StratifedCV keyword constructor resets it to MersenneTwister(rng). Otherwise some AbstractRNG object is expected.\n\nIf rng is left unspecified, rng is reset to Random.GLOBAL_RNG, in which case rows are only pre-shuffled if shuffle=true is explicitly specified.\n\n\n\n\n\n","category":"type"},{"location":"resampling/#MLJBase.evaluate!-Tuple{Machine{#s364} where #s364<:Supervised}","page":"Resampling","title":"MLJBase.evaluate!","text":"evaluate!(mach,\n          resampling=CV(),\n          measure=nothing,\n          rows=nothing,\n          weights=nothing,\n          operation=predict,\n          repeats=1,\n          acceleration=default_resource(),\n          force=false,\n          verbosity=1,\n          check_measure=true)\n\nEstimate the performance of a machine mach wrapping a supervised model in data, using the specified resampling strategy (defaulting to 6-fold cross-validation) and measure, which can be a single measure or vector.\n\nDo subtypes(MLJ.ResamplingStrategy) to obtain a list of available resampling strategies. If resampling is not an object of type MLJ.ResamplingStrategy, then a vector of pairs (of the form (train_rows, test_rows) is expected. For example, setting\n\nresampling = [(1:100), (101:200)),\n               (101:200), (1:100)]\n\ngives two-fold cross-validation using the first 200 rows of data.\n\nThe resampling strategy is applied repeatedly (Monte Carlo resampling) if repeats > 1. For example, if repeats = 10, then resampling = CV(nfolds=5, shuffle=true), generates a total of 50 (train, test) pairs for evaluation and subsequent aggregation.\n\nIf resampling isa MLJ.ResamplingStrategy then one may optionally restrict the data used in evaluation by specifying rows.\n\nAn optional weights vector may be passed for measures that support sample weights (MLJ.supports_weights(measure) == true), which is ignored by those that don't.\n\nUser-defined measures are supported; see the manual for details.\n\nIf no measure is specified, then default_measure(mach.model) is used, unless this default is nothing and an error is thrown.\n\nThe acceleration keyword argument is used to specify the compute resource (a subtype of ComputationalResources.AbstractResource) that will be used to accelerate/parallelize the resampling operation.\n\nAlthough evaluate! is mutating, mach.model and mach.args are untouched.\n\nSummary of key-word arguments\n\nresampling - resampling strategy (default is CV(nfolds=6))\nmeasure/measures - measure or vector of measures (losses, scores, etc)\nrows - vector of observation indices from which both train and test folds are constructed (default is all observations)\nweights - per-sample weights used in evaluation of specified   measure/measures where supported.\noperation - predict, predict_mean, predict_mode or predict_median; predict is the default but cannot be used with a deterministic measure if model isa Probabilistic\nrepeats - default is 1; set to a higher value for repeated (Monte Carlo) resampling\nacceleration - parallelization option; currently supported  options are instances of CPU1 (single-threaded computation)  CPUThreads (multi-threaded computation) and CPUProcesses  (multi-process computation); default is default_resource().\nforce - default is false; set to true for force cold-restart of each training event\nverbosity level, an integer defaulting to 1.\ncheck_measure - default is true\n\nReturn value\n\nA property-accessible object of type PerformanceEvaluation with these properties:\n\nmeasure: the vector of specified measures\nmeasurements: the corresponding measurements, aggregated across the test folds using the aggregation method defined for each measure (do aggregation(measure) to inspect)\nper_fold: a vector of vectors of individual test fold evaluations (one vector per measure)\nper_observation: a vector of vectors of individual observation evaluations of those measures for which reports_each_observation(measure) is true, which is otherwise reported missing.\nfitted_params_per_fold: a vector containing fitted pamarms(mach) for each      individual train fold fit of mach. \nreport_per_fold: a vector containing report(mach) for each   individual train fold fit of mach.\n\nSee also evaluate\n\n\n\n\n\n","category":"method"},{"location":"resampling/#MLJModelInterface.evaluate-Tuple{Supervised,Vararg{Any,N} where N}","page":"Resampling","title":"MLJModelInterface.evaluate","text":"evaluate(model, X, y; measure=nothing, options...)\nevaluate(model, X, y, w; measure=nothing, options...)\n\nEvaluate the performance of a supervised model model on input data X and target y, optionally specifying sample weights w for training , where supported. \n\nSee the machine version evaluate! for the complete list of options.\n\n\n\n\n\n","category":"method"},{"location":"composition/#Composition-1","page":"Composition","title":"Composition","text":"","category":"section"},{"location":"composition/#Composites-1","page":"Composition","title":"Composites","text":"","category":"section"},{"location":"composition/#","page":"Composition","title":"Composition","text":"Modules = [MLJBase]\nPages   = [\"composition/composites.jl\"]","category":"page"},{"location":"composition/#Networks-1","page":"Composition","title":"Networks","text":"","category":"section"},{"location":"composition/#","page":"Composition","title":"Composition","text":"Modules = [MLJBase]\nPages   = [\"composition/networks.jl\"]","category":"page"},{"location":"composition/#Pipelines-1","page":"Composition","title":"Pipelines","text":"","category":"section"},{"location":"composition/#","page":"Composition","title":"Composition","text":"Modules = [MLJBase]\nPages   = [\"composition/pipeline_static.jl\", \"composition/pipelines.jl\"]","category":"page"},{"location":"#MLJBase.jl-1","page":"Home","title":"MLJBase.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MLJ is a Julia framework for combining and tuning machine learning models. This repository provides core functionality for MLJ, including:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"completing the functionality for methods defined \"minimally\" in MLJ's light-weight model interface MLJModelInterface\ndefinition of machines and their associated methods, such as fit! and predict/transform\nMLJ's model composition interface, including learning networks and pipelines\nbasic utilities for manipulating data\nan extension to Distributions.jl called UnivariateFinite for randomly sampling labeled categorical data\na small interface for resampling strategies and implementations, including CV(), StratifiedCV and Holdout\nmethods for performance evaluation, based on those resampling strategies\none-dimensional hyperparameter range types, constructors and associated methods, for use with MLJTuning\na small interface for performance measures (losses and scores), enabling the integration of the LossFunctions.jl library, user-defined measures, as well as about two dozen natively defined measures.\nintegration with OpenML","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Previously MLJBase provided the model interface for integrating third party machine learning models into MLJ. That role has now shifted to the light-weight MLJModelInterface package.","category":"page"},{"location":"datasets/#Datasets-1","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Pages   = [\"data/datasets_synthetic.jl\"]","category":"page"},{"location":"datasets/#Standard-datasets-1","page":"Datasets","title":"Standard datasets","text":"","category":"section"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"To add a new dataset assuming it has a header and is, at path data/newdataset.csv","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Start by loading it with CSV:","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"fpath = joinpath(\"datadir\", \"newdataset.csv\")\ndata = CSV.read(fpath, copycols=true,\n                categorical=true)","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Load it with DelimitedFiles and Tables","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"data_raw, data_header = readdlm(fpath, ',', header=true)\ndata_table = Tables.table(data_raw; header=Symbol.(vec(data_header)))","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Retrieve the conversions:","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"for (n, st) in zip(names(data), scitype_union.(eachcol(data)))\n    println(\":$n=>$st,\")\nend","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Copy and paste the result in a coerce","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"data_table = coerce(data_table, ...)","category":"page"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Modules = [MLJBase]\nPages   = [\"data/datasets.jl\"]","category":"page"},{"location":"datasets/#MLJBase.@load_ames-Tuple{}","page":"Datasets","title":"MLJBase.@load_ames","text":"Load the full version of the well-known Ames Housing task.\n\n\n\n\n\n","category":"macro"},{"location":"datasets/#MLJBase.@load_boston-Tuple{}","page":"Datasets","title":"MLJBase.@load_boston","text":"Load a well-known public regression dataset with Continuous features.\n\n\n\n\n\n","category":"macro"},{"location":"datasets/#MLJBase.@load_crabs-Tuple{}","page":"Datasets","title":"MLJBase.@load_crabs","text":"Load a well-known crab classification dataset with nominal features.\n\n\n\n\n\n","category":"macro"},{"location":"datasets/#MLJBase.@load_iris-Tuple{}","page":"Datasets","title":"MLJBase.@load_iris","text":"Load a well-known public classification task with nominal features.\n\n\n\n\n\n","category":"macro"},{"location":"datasets/#MLJBase.@load_reduced_ames-Tuple{}","page":"Datasets","title":"MLJBase.@load_reduced_ames","text":"Load a reduced version of the well-known Ames Housing task\n\n\n\n\n\n","category":"macro"},{"location":"datasets/#MLJBase.@load_smarket-Tuple{}","page":"Datasets","title":"MLJBase.@load_smarket","text":"Load S&P Stock Market dataset, as used in (An Introduction to Statistical Learning with applications in R)https://rdrr.io/cran/ISLR/man/Smarket.html, by Witten et al (2013), Springer-Verlag, New York.\n\n\n\n\n\n","category":"macro"},{"location":"datasets/#MLJBase.load_dataset-Tuple{String,Tuple}","page":"Datasets","title":"MLJBase.load_dataset","text":"load_dataset(fpath, coercions)\n\nLoad one of standard dataset like Boston etc assuming the file is a comma separated file with a header.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#Synthetic-datasets-1","page":"Datasets","title":"Synthetic datasets","text":"","category":"section"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Modules = [MLJBase]\nPages   = [\"data/datasets_synthetic.jl\"]","category":"page"},{"location":"datasets/#MLJBase.make_blobs","page":"Datasets","title":"MLJBase.make_blobs","text":"X, y = make_blobs(n=100, p=2; kwargs...)\n\nGenerate Gaussian blobs for clustering and classification problems.\n\nReturn value\n\nBy default, a table X with p columns (features) and n rows (observations), together with a corresponding vector of n Multiclass target observations y, indicating blob membership.\n\nKeyword arguments\n\nshuffle=true: whether to shuffle the resulting points,\ncenters=3: either a number of centers or a c x p matrix with c pre-determined centers,\ncluster_std=1.0: the standard deviation(s) of each blob,\ncenter_box=(-10. => 10.): the limits of the p-dimensional cube within which the cluster centers are drawn if they are not provided,\neltype=Float64: machine type of points (any subtype of  AbstractFloat).\nrng=nothing: any AbstractRNG object, or integer to seed a MersenneTwister (for reproducibility).\nas_table=true: whether to return the points as a table (true) or a matrix (false). If false the target y has integer element type. \n\nExample\n\nX, y = make_blobs(100, 3; centers=2, cluster_std=[1.0, 3.0])\n\n\n\n\n\n","category":"function"},{"location":"datasets/#MLJBase.make_circles","page":"Datasets","title":"MLJBase.make_circles","text":"X, y = make_circles(n=100; kwargs...)\n\nGenerate n labeled points close to two concentric circles for classification and clustering models.\n\nReturn value\n\nBy default, a table X with 2 columns and n rows (observations), together with a corresponding vector of n Multiclass target observations y. The target is either 0 or 1, corresponding to membership to the smaller or larger circle, respectively.\n\nKeyword arguments\n\nshuffle=true: whether to shuffle the resulting points,\nnoise=0: standard deviation of the Gaussian noise added to the data,\nfactor=0.8: ratio of the smaller radius over the larger one,\n\neltype=Float64: machine type of points (any subtype of  AbstractFloat).\nrng=nothing: any AbstractRNG object, or integer to seed a MersenneTwister (for reproducibility).\nas_table=true: whether to return the points as a table (true) or a matrix (false). If false the target y has integer element type. \n\nExample\n\nX, y = make_circles(100; noise=0.5, factor=0.3)\n\n\n\n\n\n","category":"function"},{"location":"datasets/#MLJBase.make_moons","page":"Datasets","title":"MLJBase.make_moons","text":"    make_moons(n::Int=100; kwargs...)\n\nGenerates labeled two-dimensional points lying close to two interleaved semi-circles, for use with classification and clustering models.\n\nReturn value\n\nBy default, a table X with 2 columns and n rows (observations), together with a corresponding vector of n Multiclass target observations y. The target is either 0 or 1, corresponding to membership to the left or right semi-circle.\n\nKeyword arguments\n\nshuffle=true: whether to shuffle the resulting points,\nnoise=0.1: standard deviation of the Gaussian noise added to the data,\nxshift=1.0: horizontal translation of the second center with respect to the first one.\nyshift=0.3: vertical translation of the second center with respect to the first one.  \neltype=Float64: machine type of points (any subtype of  AbstractFloat).\nrng=nothing: any AbstractRNG object, or integer to seed a MersenneTwister (for reproducibility).\nas_table=true: whether to return the points as a table (true) or a matrix (false). If false the target y has integer element type. \n\nExample\n\nX, y = make_moons(100; noise=0.5)\n\n\n\n\n\n","category":"function"},{"location":"datasets/#MLJBase.make_regression","page":"Datasets","title":"MLJBase.make_regression","text":"make_regression(n, p; kwargs...)\n\nGenerate Gaussian input features and a linear response with Gaussian noise, for use with regression models.\n\nReturn value\n\nBy default, a table X with p columns and n rows (observations), together with a corresponding vector of n Continuous target observations y.\n\nKeywords\n\n`intercept=true: whether to generate data from a model with intercept,\nsparse=0: portion of the generating weight vector that is sparse,\nnoise=0.1: standard deviation of the Gaussian noise added to the response,\noutliers=0: portion of the response vector to make as outliers by adding a random quantity with high variance. (Only applied if binary is false)\nbinary=false: whether the target should be binarized (via a sigmoid).\neltype=Float64: machine type of points (any subtype of  AbstractFloat).\nrng=nothing: any AbstractRNG object, or integer to seed a MersenneTwister (for reproducibility).\nas_table=true: whether to return the points as a table (true) or a matrix (false). \n\nExample\n\nX, y = make_regression(100, 5; noise=0.5, sparse=0.2, outliers=0.1)\n\n\n\n\n\n","category":"function"},{"location":"datasets/#MLJBase.augment_X-Tuple{Array{#s543,2} where #s543<:Real,Bool}","page":"Datasets","title":"MLJBase.augment_X","text":"augment_X(X, fit_intercept)\n\nGiven a matrix X, append a column of ones if fit_intercept is true. See make_regression.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.finalize_Xy-NTuple{6,Any}","page":"Datasets","title":"MLJBase.finalize_Xy","text":"finalize_Xy(X, y, shuffle, as_table, eltype, rng; clf)\n\nInternal function to  finalize the make_* functions.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.outlify!-Tuple{Any,Any,Any}","page":"Datasets","title":"MLJBase.outlify!","text":"Add outliers to portion s of vector.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.runif_ab-NTuple{5,Any}","page":"Datasets","title":"MLJBase.runif_ab","text":"runif_ab(rng, n, p, a, b)\n\nInternal function to generate n points in [a, b]ᵖ uniformly at random.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.sigmoid-Tuple{Float64}","page":"Datasets","title":"MLJBase.sigmoid","text":"sigmoid(x)\n\nReturn the sigmoid computed in a numerically stable way:\n\nσ(x) = 1(1+exp(-x))\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.sparsify!-Tuple{Any,Any,Any}","page":"Datasets","title":"MLJBase.sparsify!","text":"sparsify!(rng, θ, s)\n\nMake portion s of vector θ exactly 0.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#Utility-functions-1","page":"Datasets","title":"Utility functions","text":"","category":"section"},{"location":"datasets/#","page":"Datasets","title":"Datasets","text":"Modules = [MLJBase]\nPages   = [\"data/data.jl\"]","category":"page"},{"location":"datasets/#MLJBase.complement-Tuple{Any,Any}","page":"Datasets","title":"MLJBase.complement","text":"complement(folds, i)\n\nThe complement of the ith fold of folds in the concatenation of all elements of folds. Here folds is a vector or tuple of integer vectors, typically representing row indices or a vector, matrix or table.\n\ncomplement(([1,2], [3,], [4, 5]), 2) # [1 ,2, 4, 5]\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.corestrict-Union{Tuple{N}, Tuple{Tuple{Vararg{T,N}} where T,Any}} where N","page":"Datasets","title":"MLJBase.corestrict","text":"corestrict(X, folds, i)\n\nThe restriction of X, a vector, matrix or table, to the complement of the ith fold of folds, where folds is a tuple of vectors of row indices.\n\nThe method is curried, so that corestrict(folds, i) is the operator on data defined by corestrict(folds, i)(X) = corestrict(X, folds, i).\n\nExample\n\nfolds = ([1, 2], [3, 4, 5],  [6,])\ncorestrict([:x1, :x2, :x3, :x4, :x5, :x6], folds, 2) # [:x1, :x2, :x6]\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.partition-Tuple{AbstractArray{Int64,1},Vararg{Real,N} where N}","page":"Datasets","title":"MLJBase.partition","text":"partition(rows::AbstractVector{Int}, fractions...;\n          shuffle=nothing, rng=Random.GLOBAL_RNG, stratify=nothing)\n\nSplits the vector rows into a tuple of vectors whose lengths are given by the corresponding fractions of length(rows) where valid fractions are in (0,1) and sum up to less than 1. The last fraction is not provided, as it is inferred from the preceding ones. So, for example,\n\njulia> partition(1:1000, 0.8)\n([1,...,800], [801,...,1000])\n\njulia> partition(1:1000, 0.2, 0.7)\n([1,...,200], [201,...,900], [901,...,1000])\n\nKeywords\n\nshuffle=nothing:        if set to  true, shuffles the rows before taking fractions.\nrng=Random.GLOBAL_RNG:  specifies the random number generator to be used, can be an integer                           seed. If specified, and shuffle === nothing is interpreted as true.\nstratify=nothing:       if a vector is specified, the partition will match the stratification                           of the given vector. In that case, shuffle cannot be false.\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.restrict-Union{Tuple{N}, Tuple{Tuple{Vararg{T,N}} where T,Any}} where N","page":"Datasets","title":"MLJBase.restrict","text":"restrict(X, folds, i)\n\nThe restriction of X, a vector, matrix or table, to the ith fold of folds, where folds is a tuple of vectors of row indices.\n\nThe method is curried, so that restrict(folds, i) is the operator on data defined by restrict(folds, i)(X) = restrict(X, folds, i).\n\nExample\n\nfolds = ([1, 2], [3, 4, 5],  [6,])\nrestrict([:x1, :x2, :x3, :x4, :x5, :x6], folds, 2) # [:x3, :x4, :x5]\n\nSee also corestrict\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJBase.unpack-Tuple{Any,Vararg{Any,N} where N}","page":"Datasets","title":"MLJBase.unpack","text":"t1, t2, ...., tk = unnpack(table, f1, f2, ... fk;\n                           wrap_singles=false,\n                           shuffle=false,\n                           rng::Union{AbstractRNG,Int}=nothing)\n\n)\n\nSplit any Tables.jl compatible table into smaller tables (or vectors) t1, t2, ..., tk by making selections without replacement from the column names defined by the filters f1, f2, ..., fk. A filter is any object f such that f(name) is true or false for each column name::Symbol of table.\n\nWhenever a returned table contains a single column, it is converted to a vector unless wrap_singles=true.\n\nScientific type conversions can be optionally specified (note semicolon):\n\nunpack(table, t...; wrap_singles=false, col1=>scitype1, col2=>scitype2, ... )\n\nIf shuffle=true then the rows of table are first shuffled, using the global RNG, unless rng is specified; if rng is an integer, it specifies the seed of an automatically generated Mersenne twister. If rng is specified then shuffle=true is implicit.\n\nExample\n\njulia> table = DataFrame(x=[1,2], y=['a', 'b'], z=[10.0, 20.0], w=[:A, :B])\njulia> Z, XY = unpack(table, ==(:z), !=(:w);\n               :x=>Continuous, :y=>Multiclass)\njulia> XY\n2×2 DataFrame\n│ Row │ x       │ y            │\n│     │ Float64 │ Categorical… │\n├─────┼─────────┼──────────────┤\n│ 1   │ 1.0     │ 'a'          │\n│ 2   │ 2.0     │ 'b'          │\n\njulia> Z\n2-element Array{Float64,1}:\n 10.0\n 20.0\n\n\n\n\n\n","category":"method"},{"location":"datasets/#MLJModelInterface.transform-Tuple{Union{CategoricalArrays.CategoricalArray, CategoricalArrays.CategoricalValue},Any}","page":"Datasets","title":"MLJModelInterface.transform","text":"transform(e::Union{CategoricalElement,CategoricalArray,CategoricalPool},  X)\n\nTransform the specified object X into a categorical version, using the pool contained in e. Here X is a raw value (an element of levels(e)) or an AbstractArray of such values.\n\n```julia v = categorical([:x, :y, :y, :x, :x]) julia> transform(v, :x) CategoricalValue{Symbol,UInt32} :x\n\njulia> transform(v[1], [:x :x; missing :y]) 2×2 CategoricalArray{Union{Missing, Symbol},2,UInt32}:  :x       :x  missing  :y\n\n\n\n\n\n","category":"method"}]
}
