<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · MLJBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MLJBase.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../measures/">Measures</a></li><li><a class="tocitem" href="../resampling/">Resampling</a></li><li><a class="tocitem" href="../composition/">Composition</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../openml/">OpenML</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#Machines-1"><span>Machines</span></a></li><li><a class="tocitem" href="#Parameter-Inspection-1"><span>Parameter Inspection</span></a></li><li><a class="tocitem" href="#Show-1"><span>Show</span></a></li><li><a class="tocitem" href="#Utility-functions-1"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/master/docs/src/utilities.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h1><h2 id="Machines-1"><a class="docs-heading-anchor" href="#Machines-1">Machines</a><a class="docs-heading-anchor-permalink" href="#Machines-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.report-Tuple{AbstractMachine}" href="#MLJBase.report-Tuple{AbstractMachine}"><code>MLJBase.report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">report(mach)</code></pre><p>Return the report for a machine <code>mach</code> that has been <code>fit!</code>, for example the coefficients in a linear model.</p><p>This is a named tuple and human-readable if possible.</p><p>If <code>mach</code> is a machine for a composite model, then the returned value has keys <code>machines</code> and <code>report_given_machine</code>, whose corresponding values are a vector of (nodal) machines appearing in the underlying learning network, and a dictionary of reports keyed on those machines.</p><pre><code class="language-julia">using MLJ
X, y = @load_crabs;
pipe = @pipeline MyPipe(
    std = Standardizer(),
    clf = @load LinearBinaryClassifier pkg=GLM
)
mach = machine(MyPipe(), X, y) |&gt; fit!
r = report(mach)
r.machines
2-element Array{Any,1}:
 NodalMachine{LinearBinaryClassifier{LogitLink}} @ 1…57
 NodalMachine{Standardizer} @ 7…33

r.report_given_machine[machs[1]]
(deviance = 3.8893386087844543e-7,
 dof_residual = 195.0,
 stderror = [18954.83496713119, ..., 2111.1294584763386],
 vcov = [3.592857686311793e8 ... .442545425533723e6;
         ...
         5.38856837634321e6 ... 2.1799125705781363e7 4.456867590446599e6],)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/machines.jl#LL225-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit!-Tuple{AbstractMachine}" href="#StatsBase.fit!-Tuple{AbstractMachine}"><code>StatsBase.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(mach::Machine; rows=nothing, verbosity=1, force=false)</code></pre><p>When called for the first time, call <code>fit(mach.model, verbosity, args...)</code>, where <code>args = machine.args</code>, if <code>rows==nothing</code>, or</p><pre><code class="language-none">args = [selectrows(arg, rows) for arg in mach.args]</code></pre><p>otherwise, storing the returned fit-result and report in <code>mach</code>. Subsequent calls do nothing unless: (i) <code>force=true</code>, or (ii) the specified <code>rows</code> are different from those used the last time a fit-result was computed, or (iii) <code>mach.model</code> has changed since the last time a fit-result was computed (the machine is <em>stale</em>). In cases (i) or (ii) <code>MLJBase.fit</code> is called again. Otherwise, <code>MLJBase.update</code> is called.</p><pre><code class="language-none">fit!(mach::NodalMachine; rows=nothing, verbosity=1, force=false)</code></pre><p>When called for the first time, attempt to call <code>fit(mach.model, verbosity, args...)</code>, where <code>args = [arg() for arg in mach.args</code>, if <code>rows==nothing</code>, and</p><pre><code class="language-none">args =  [arg(rows=rows) for arg in mach.args]</code></pre><p>otherwise. This will fail if an argument of the machine depends ultimately on some other untrained machine for successful calling, but this is resolved by instead calling <code>fit!</code> any node <code>N</code> for which <code>mach in machines(N)</code> is true, which trains all necessary machines in an appropriate order. Subsequent <code>fit!</code> calls do nothing unless: (i) <code>force=true</code>, or (ii) some machine on which <code>mach</code> depends has computed a new fit-result since <code>mach</code> last computed its fit-result, or (iii) the specified <code>rows</code> have changed since the last time a fit-result was last computed, or (iv) <code>mach</code> is stale (see below). In cases (i), (ii) or (iii), <code>MLJBase.fit</code> is called. Otherwise <code>MLJBase.update</code> is called.</p><p>A machine <code>mach</code> is <em>stale</em> if <code>mach.model</code> has changed since the last time a fit-result was computed, or if one of its training arguments is <code>stale</code>. A node <code>N</code> is stale if <code>N.machine</code> is stale or one of its arguments is stale. <code>Source</code> nodes are never stale.</p><p>Note that a nodal machine obtains its training data by <em>calling</em> its node arguments on the specified <code>rows</code> (rather than <em>indexing</em> its arguments on those rows) and that this calling is a recursive operation on nodes upstream of those arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/machines.jl#LL102-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.save-Tuple{Any,AbstractMachine}" href="#MLJModelInterface.save-Tuple{Any,AbstractMachine}"><code>MLJModelInterface.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MLJ.save(filename, mach::AbstractMachine; kwargs...)
MLJ.save(io, mach::Machine; kwargs...)

MLJBase.save(filename, mach::AbstractMachine; kwargs...)
MLJBase.save(io, mach::Machine; kwargs...)</code></pre><p>Serialize the machine <code>mach</code> to a file with path <code>filename</code>, or to an input/output stream <code>io</code> (at least <code>IOBuffer</code> instances are supported).</p><p>The format is JLSO (a wrapper for julia native or BSON serialization) unless a custom format has been implemented for the model type of <code>mach.model</code>. The keyword arguments <code>kwargs</code> are passed to the format-specific serializer, which in the JSLO case include these:</p><table><tr><th style="text-align: right">keyword</th><th style="text-align: right">values</th><th style="text-align: right">default</th></tr><tr><td style="text-align: right"><code>format</code></td><td style="text-align: right"><code>:julia_serialize</code>, <code>:BSON</code></td><td style="text-align: right"><code>:julia_serialize</code></td></tr><tr><td style="text-align: right"><code>compression</code></td><td style="text-align: right"><code>:gzip</code>, <code>:none</code></td><td style="text-align: right"><code>:none</code></td></tr></table><p>See (see <a href="https://github.com/invenia/JLSO.jl">https://github.com/invenia/JLSO.jl</a> for details.</p><p>Machines are de-serialized using the <code>machine</code> constructor as shown in the example below. Data (or nodes) may be optionally passed to the constructor for retraining on new data using the saved model.</p><p><strong>Example</strong></p><pre><code class="language-none">using MLJ
tree = @load DecisionTreeClassifier
X, y = @load_iris
mach = fit!(machine(tree, X, y))

MLJ.save(&quot;tree.jlso&quot;, mach, compression=:none)
mach_predict_only = machine(&quot;tree.jlso&quot;)
predict(mach_predict_only, X)

mach2 = machine(&quot;tree.jlso&quot;, selectrows(X, 1:100), y[1:100])
predict(mach2, X) # same as above

fit!(mach2) # saved learned parameters are over-written
predict(mach2, X) # not same as above

# using a buffer:
io = IOBuffer()
MLJ.save(io, mach)
seekstart(io)
predict_only_mach = machine(io)
predict(predict_only_mach, X)</code></pre><div class="admonition is-warning"><header class="admonition-header">Only load files from trusted sources</header><div class="admonition-body"><p>Maliciously constructed JLSO files, like pickles, and most other general purpose serialization formats, can allow for arbitrary code execution during loading. This means it is possible for someone to use a JLSO file that looks like a serialized MLJ machine as a <a href="https://en.wikipedia.org/wiki/Trojan_horse_(computing)">Trojan horse</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/machines.jl#LL269-L331">source</a></section></article><h2 id="Parameter-Inspection-1"><a class="docs-heading-anchor" href="#Parameter-Inspection-1">Parameter Inspection</a><a class="docs-heading-anchor-permalink" href="#Parameter-Inspection-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.params-Tuple{Any}" href="#MLJBase.params-Tuple{Any}"><code>MLJBase.params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">params(m::MLJType)</code></pre><p>Recursively convert any transparent object <code>m</code> into a named tuple, keyed on the fields of <code>m</code>. An object is <em>transparent</em> if <code>MLJBase.istransparent(m) == true</code>. The named tuple is possibly nested because <code>params</code> is recursively applied to the field values, which themselves might be transparent.</p><p>Most objects of type <code>MLJType</code> are transparent.</p><pre><code class="language-none">julia&gt; params(EnsembleModel(atom=ConstantClassifier()))
(atom = (target_type = Bool,),
 weights = Float64[],
 bagging_fraction = 0.8,
 rng_seed = 0,
 n = 100,
 parallel = true,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/parameter_inspection.jl#LL4-L23">source</a></section></article><h2 id="Show-1"><a class="docs-heading-anchor" href="#Show-1">Show</a><a class="docs-heading-anchor-permalink" href="#Show-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.color_off-Tuple{}" href="#MLJBase.color_off-Tuple{}"><code>MLJBase.color_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">color_off()</code></pre><p>Suppress color and bold output at the REPL for displaying MLJ objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.color_on-Tuple{}" href="#MLJBase.color_on-Tuple{}"><code>MLJBase.color_on</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">color_on()</code></pre><p>Enable color and bold output at the REPL, for enhanced display of MLJ objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@constant-Tuple{Any}" href="#MLJBase.@constant-Tuple{Any}"><code>MLJBase.@constant</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@constant x = value</code></pre><p>Equivalent to <code>const x = value</code> but registers the binding thus:</p><pre><code class="language-none">MLJBase.HANDLE_GIVEN_ID[objectid(value)] = :x</code></pre><p>Registered objects get displayed using the variable name to which it was bound in calls to <code>show(x)</code>, etc.</p><p>WARNING: As with any <code>const</code> declaration, binding <code>x</code> to new value of the same type is not prevented and the registration will not be updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL25-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@more-Tuple{}" href="#MLJBase.@more-Tuple{}"><code>MLJBase.@more</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@more</code></pre><p>Entered at the REPL, equivalent to <code>show(ans, 100)</code>. Use to get a recursive description of all fields of the last REPL value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL203-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase._recursive_show-Tuple{IO,MLJType,Any,Any}" href="#MLJBase._recursive_show-Tuple{IO,MLJType,Any,Any}"><code>MLJBase._recursive_show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_recursive_show(stream, object, current_depth, depth)</code></pre><p>Generate a table of the field values of the <code>MLJType</code> object, dislaying each value by calling the method <code>_show</code> on it. The behaviour of <code>_show(stream, f)</code> is as follows:</p><ol><li>If <code>f</code> is itself a <code>MLJType</code> object, then its short form is shown</li></ol><p>and <code>_recursive_show</code> generates as separate table for each of its field values (and so on, up to a depth of argument <code>depth</code>).</p><ol><li>Otherwise <code>f</code> is displayed as &quot;(omitted T)&quot; where <code>T = typeof(f)</code>,</li></ol><p>unless <code>istoobig(f)</code> is false (the <code>istoobig</code> fall-back for arbitrary types being <code>true</code>). In the latter case, the long (ie, MIME&quot;plain/text&quot;) form of <code>f</code> is shown. To override this behaviour, overload the <code>_show</code> method for the type in question.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL301-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.abbreviated-Tuple{Any}" href="#MLJBase.abbreviated-Tuple{Any}"><code>MLJBase.abbreviated</code></a> — <span class="docstring-category">Method</span></header><section><div><p>to display abbreviated versions of integers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.handle-Tuple{Any}" href="#MLJBase.handle-Tuple{Any}"><code>MLJBase.handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>return abbreviated object id (as string) or it&#39;s registered handle (as string) if this exists</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/show.jl#LL57-L59">source</a></section></article><h2 id="Utility-functions-1"><a class="docs-heading-anchor" href="#Utility-functions-1">Utility functions</a><a class="docs-heading-anchor-permalink" href="#Utility-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.flat_values-Tuple{NamedTuple}" href="#MLJBase.flat_values-Tuple{NamedTuple}"><code>MLJBase.flat_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flat_values(t::NamedTuple)</code></pre><p>View a nested named tuple <code>t</code> as a tree and return, as a tuple, the values at the leaves, in the order they appear in the original tuple.</p><pre><code class="language-julia-repl">julia&gt; t = (X = (x = 1, y = 2), Y = 3)
julia&gt; flat_values(t)
(1, 2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL80-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.recursive_getproperty-Tuple{Any,Symbol}" href="#MLJBase.recursive_getproperty-Tuple{Any,Symbol}"><code>MLJBase.recursive_getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recursive_getproperty(object, nested_name::Expr)</code></pre><p>Call getproperty recursively on <code>object</code> to extract the value of some nested property, as in the following example:</p><pre><code class="language-none">julia&gt; object = (X = (x = 1, y = 2), Y = 3)
julia&gt; recursive_getproperty(object, :(X.y))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.recursive_setproperty!-Tuple{Any,Symbol,Any}" href="#MLJBase.recursive_setproperty!-Tuple{Any,Symbol,Any}"><code>MLJBase.recursive_setproperty!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recursively_setproperty!(object, nested_name::Expr, value)</code></pre><p>Set a nested property of an <code>object</code> to <code>value</code>, as in the following example:</p><pre><code class="language-none">julia&gt; mutable struct Foo
           X
           Y
       end

julia&gt; mutable struct Bar
           x
           y
       end

julia&gt; object = Foo(Bar(1, 2), 3)
Foo(Bar(1, 2), 3)

julia&gt; recursively_setproperty!(object, :(X.y), 42)
42

julia&gt; object
Foo(Bar(1, 42), 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL136-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.unwind-Tuple" href="#MLJBase.unwind-Tuple"><code>MLJBase.unwind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwind(iterators...)</code></pre><p>Represent all possible combinations of values generated by <code>iterators</code> as rows of a matrix <code>A</code>. In more detail, <code>A</code> has one column for each iterator in <code>iterators</code> and one row for each distinct possible combination of values taken on by the iterators. Elements in the first column cycle fastest, those in the last clolumn slowest.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; iterators = ([1, 2], [&quot;a&quot;,&quot;b&quot;], [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);
julia&gt; MLJTuning.unwind(iterators...)
12×3 Array{Any,2}:
 1  &quot;a&quot;  &quot;x&quot;
 2  &quot;a&quot;  &quot;x&quot;
 1  &quot;b&quot;  &quot;x&quot;
 2  &quot;b&quot;  &quot;x&quot;
 1  &quot;a&quot;  &quot;y&quot;
 2  &quot;a&quot;  &quot;y&quot;
 1  &quot;b&quot;  &quot;y&quot;
 2  &quot;b&quot;  &quot;y&quot;
 1  &quot;a&quot;  &quot;z&quot;
 2  &quot;a&quot;  &quot;z&quot;
 1  &quot;b&quot;  &quot;z&quot;
 2  &quot;b&quot;  &quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL247-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@set_defaults-Tuple{Any}" href="#MLJBase.@set_defaults-Tuple{Any}"><code>MLJBase.@set_defaults</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@set_defaults ModelType(args...)
@set_defaults ModelType args</code></pre><p>Create a keyword constructor for any type <code>ModelType&lt;:MLJBase.Model</code>, using as default values those listed in <code>args</code>. These must include a value for every field, and in the order appearing in <code>fieldnames(ModelType)</code>.</p><p>The constructor does not call <code>MLJBase.clean!(model)</code> on the instantiated object <code>model</code>. This method is for internal use only (by <code>@from_network macro</code>) as it is depreciated by <code>@mlj_model</code> macro. </p><p><strong>Example</strong></p><p>mutable struct Foo       x::Int       y    end</p><p>@set_defaults Foo(1,2)</p><p>julia&gt; Foo()    Foo(1, 2)</p><p>julia&gt; Foo(x=1, y=&quot;house&quot;)    Foo(1, &quot;house&quot;)</p><p>@set_defaults Foo [4, 5]</p><p>julia&gt; Foo()    Foo(4, 5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL12-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase._permute_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Array{Int64,1}}" href="#MLJBase._permute_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Array{Int64,1}}"><code>MLJBase._permute_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>permute</em>rows(obj, perm)</p><p>Internal function to return a vector or matrix with permuted rows given the permutation <code>perm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.check_dimensions-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#MLJBase.check_dimensions-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>MLJBase.check_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_dimension(X, Y)</code></pre><p>Check that two vectors or matrices have matching dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.shuffle_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#MLJBase.shuffle_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>MLJBase.shuffle_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><p>shuffle_rows(X, Y, ...; rng=)</p><p>Return a shuffled view of a vector or  matrix <code>X</code> (or set of such) using a random permutation (which can be seeded specifying <code>rng</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/f99c4578efb9239c5e3daf10f4f3c83536ca8f6a/src/utilities.jl#LL195-L200">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../openml/">« OpenML</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 May 2020 02:17">Monday 4 May 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
