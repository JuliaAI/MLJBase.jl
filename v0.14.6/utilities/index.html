<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · MLJBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MLJBase.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../measures/">Measures</a></li><li><a class="tocitem" href="../resampling/">Resampling</a></li><li><a class="tocitem" href="../composition/">Composition</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../openml/">OpenML</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#Machines-1"><span>Machines</span></a></li><li><a class="tocitem" href="#Parameter-Inspection-1"><span>Parameter Inspection</span></a></li><li><a class="tocitem" href="#Show-1"><span>Show</span></a></li><li><a class="tocitem" href="#Utility-functions-1"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/master/docs/src/utilities.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h1><h2 id="Machines-1"><a class="docs-heading-anchor" href="#Machines-1">Machines</a><a class="docs-heading-anchor-permalink" href="#Machines-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.anonymize!-Tuple{Any}" href="#MLJBase.anonymize!-Tuple{Any}"><code>MLJBase.anonymize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">anonymize!(sources)</code></pre><p>Returns a named tuple <code>(sources=..., data=....)</code> whose values are the provided source nodes and their contents respectively, and clears the contents of those source nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/composition/learning_networks/machines.jl#LL115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.fit_only!-Tuple{Machine}" href="#MLJBase.fit_only!-Tuple{Machine}"><code>MLJBase.fit_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MLJBase.fit_only!(mach::Machine; rows=nothing, verbosity=1, force=false)</code></pre><p>Without mutating any other machine on which it may depend, perform one of the following actions to the machine <code>mach</code>, using the data and model bound to it, and restricting the data to <code>rows</code> if specified:</p><ul><li><p><em>Ab initio training.</em> Ignoring any previous learned parameters and cache, compute and store new learned parameters. Increment <code>mach.state</code>.</p></li><li><p><em>Training update.</em> Making use of previous learned parameters and/or  cache, replace or mutate existing learned parameters. The effect is  the same (or nearly the same) as in ab initio training, but may be  faster or use less memory, assuming the model supports an update  option (implements <code>MLJBase.update</code>). Increment <code>mach.state</code>.</p></li><li><p><em>No-operation.</em> Leave existing learned parameters untouched. Do not  increment <code>mach.state</code>.</p></li></ul><p><strong>Training action logic</strong></p><p>For the action to be a no-operation, either <code>mach.frozen == true</code> or none of the following apply:</p><ul><li><p>(i) <code>mach</code> has never been trained (<code>mach.state == 0</code>).</p></li><li><p>(ii) <code>force == true</code></p></li><li><p>(iii) The <code>state</code> of some other machine on which <code>mach</code> depends has changed since the last time <code>mach</code> was trained (ie, the last time <code>mach.state</code> was last incremented)</p></li><li><p>(iv) The specified <code>rows</code> have changed since the last retraining.</p></li><li><p>(v) <code>mach.model</code> has changed since the last retraining.</p></li></ul><p>In cases (i) - (iv), <code>mach</code> is trained ab initio. In case (v) a training update is applied.</p><p>To freeze or unfreeze <code>mach</code>, use <code>freeze!(mach)</code> or <code>thaw!(mach)</code>.</p><p><strong>Implementation detail</strong></p><p>The data to which a machine is bound is stored in <code>mach.args</code>. Each element of <code>args</code> is either a <code>Node</code> object, or, in the case that concrete data was bound to the machine, it is concrete data wrapped in a <code>Source</code> node. In all cases, to obtain concrete data for actual training, each argument <code>N</code> is called, as in <code>N()</code> or <code>N(rows=rows)</code>, and either <code>MLJBase.fit</code> (ab initio training) or <code>MLJBase.update</code> (training update) is dispatched on <code>mach.model</code> and this data. See the &quot;Adding models for general use&quot; section of the MLJ documentation for more on these lower-level training methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL326-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.freeze!-Tuple{Machine}" href="#MLJBase.freeze!-Tuple{Machine}"><code>MLJBase.freeze!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">freeze!(mach)</code></pre><p>Freeze the machine <code>mach</code> so that it will never be retrained (unless thawed).</p><p>See also <a href="#MLJBase.thaw!-Tuple{Machine}"><code>thaw!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL244-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.machine" href="#MLJBase.machine"><code>MLJBase.machine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">machine(model, args...)</code></pre><p>Construct a <code>Machine</code> object binding a <code>model</code>, storing hyper-parameters of some machine learning algorithm, to some data, <code>args</code>. When building a learning network, <code>Node</code> objects can be substituted for concrete data.</p><pre><code class="language-none">machine(Xs; oper1=node1, oper2=node2, ...)
machine(Xs, ys; oper1=node1, oper2=node2, ...)
machine(Xs, ys, ws; oper1=node1, oper2=node2, ...)</code></pre><p>Construct a special machine called a <em>learning network machine</em>, that &quot;wraps&quot; a learning network, usually in preparation to export the network as a stand-alone composite model type. The keyword arguments declare what nodes are called when operations, such as <code>predict</code> and <code>transform</code>, are called on the machine.</p><p>In addition to the operations named in the constructor, the methods <code>fit!</code>, <code>report</code>, and <code>fitted_params</code> can be applied as usual to the machine constructed.</p><pre><code class="language-none">machine(Probablistic(), args...; kwargs...)
machine(Deterministic(), args...; kwargs...)
machine(Unsupervised(), args...; kwargs...)
machine(Static(), args...; kwargs...)</code></pre><p>Same as above, but specifying explicitly the kind of model the learning network is to meant to represent.</p><p>Learning network machines are not to be confused with an ordinary machine that happens to be bound to a stand-alone composite model (i.e., an <em>exported</em> learning network).</p><p><strong>Examples</strong></p><p>Supposing a supervised learning network&#39;s final predictions are obtained by calling a node <code>yhat</code>, then the code</p><pre><code class="language-julia">mach = machine(Deterministic(), Xs, ys; predict=yhat)
fit!(mach; rows=train)
predictions = predict(mach, Xnew) # `Xnew` concrete data</code></pre><p>is  equivalent to</p><pre><code class="language-julia">fit!(yhat, rows=train)
predictions = yhat(Xnew)</code></pre><p>Here <code>Xs</code> and <code>ys</code> are the source nodes receiving, respectively, the input and target data.</p><p>In a unsupervised learning network for clustering, with single source node <code>Xs</code> for inputs, and in which the node <code>Xout</code> delivers the output of dimension reduction, and <code>yhat</code> the class labels, one can write</p><pre><code class="language-julia">mach = machine(Unsupervised(), Xs; transform=Xout, predict=yhat)
fit!(mach)
transformed = transform(mach, Xnew) # `Xnew` concrete data
predictions = predict(mach, Xnew)</code></pre><p>which is equivalent to</p><pre><code class="language-julia">fit!(Xout)
fit!(yhat)
transformed = Xout(Xnew)
predictions = yhat(Xnew)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL122-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.report-Tuple{Machine}" href="#MLJBase.report-Tuple{Machine}"><code>MLJBase.report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">report(mach)</code></pre><p>Return the report for a machine <code>mach</code> that has been <code>fit!</code>, for example the coefficients in a linear model.</p><p>This is a named tuple and human-readable if possible.</p><p>If <code>mach</code> is a machine for a composite model, such as a model constructed using <code>@pipeline</code>, then the returned named tuple has the composite type&#39;s field names as keys. The corresponding value is the report for the machine in the underlying learning network bound to that model. (If multiple machines share the same model, then the value is a vector.)</p><pre><code class="language-julia">using MLJ
@load LinearBinaryClassifier pkg=GLM
X, y = @load_crabs;
pipe = @pipeline Standardizer LinearBinaryClassifier
mach = machine(pipe, X, y) |&gt; fit!

julia&gt; report(mach).linear_binary_classifier
(deviance = 3.8893386087844543e-7,
 dof_residual = 195.0,
 stderror = [18954.83496713119, 6502.845740757159, 48484.240246060406, 34971.131004997274, 20654.82322484894, 2111.1294584763386],
 vcov = [3.592857686311793e8 9.122732393971942e6 … -8.454645589364915e7 5.38856837634321e6; 9.122732393971942e6 4.228700272808351e7 … -4.978433790526467e7 -8.442545425533723e6; … ; -8.454645589364915e7 -4.978433790526467e7 … 4.2662172244975924e8 2.1799125705781363e7; 5.38856837634321e6 -8.442545425533723e6 … 2.1799125705781363e7 4.456867590446599e6],)
</code></pre><p>Additional keys, <code>machines</code> and <code>report_given_machine</code>, give a list of <em>all</em> machines in the underlying network, and a dictionary of reports keyed on those machines.</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL540-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.thaw!-Tuple{Machine}" href="#MLJBase.thaw!-Tuple{Machine}"><code>MLJBase.thaw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">thaw!(mach)</code></pre><p>Unfreeze the machine <code>mach</code> so that it can be retrained.</p><p>See also <a href="#MLJBase.freeze!-Tuple{Machine}"><code>freeze!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fitted_params-Tuple{Machine}" href="#MLJModelInterface.fitted_params-Tuple{Machine}"><code>MLJModelInterface.fitted_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitted_params(mach)</code></pre><p>Return the learned parameters for a machine <code>mach</code> that has been <code>fit!</code>, for example the coefficients in a linear model.</p><p>This is a named tuple and human-readable if possible.</p><p>If <code>mach</code> is a machine for a composite model, such as a model constructed using <code>@pipeline</code>, then the returned named tuple has the composite type&#39;s field names as keys. The corresponding value is the fitted parameters for the machine in the underlying learning network bound to that model. (If multiple machines share the same model, then the value is a vector.)</p><pre><code class="language-julia">using MLJ
@load LogisticClassifier pkg=MLJLinearModels
X, y = @load_crabs;
pipe = @pipeline Standardizer LogisticClassifier
mach = machine(pipe, X, y) |&gt; fit!

julia&gt; fitted_params(mach).logistic_classifier
(classes = CategoricalArrays.CategoricalValue{String,UInt32}[&quot;B&quot;, &quot;O&quot;],
 coefs = Pair{Symbol,Float64}[:FL =&gt; 3.7095037897680405, :RW =&gt; 0.1135739140854546, :CL =&gt; -1.6036892745322038, :CW =&gt; -4.415667573486482, :BD =&gt; 3.238476051092471],
 intercept = 0.0883301599726305,)</code></pre><p>Additional keys, <code>machines</code> and <code>fitted_params_given_machine</code>, give a list of <em>all</em> machines in the underlying network, and a dictionary of fitted parameters keyed on those machines.</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL497-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit!-Tuple{Machine{#s39} where #s39&lt;:Union{DeterministicSurrogate, IntervalSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate}}" href="#StatsBase.fit!-Tuple{Machine{#s39} where #s39&lt;:Union{DeterministicSurrogate, IntervalSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate}}"><code>StatsBase.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(mach::Machine{&lt;:Surrogate};
     rows=nothing,
     acceleration=CPU1(),
     verbosity=1,
     force=false))</code></pre><p>Train the complete learning network wrapped by the machine <code>mach</code>.</p><p>More precisely, if <code>s</code> is the learning network signature used to construct <code>mach</code>, then call <code>fit!(N)</code>, where <code>N = glb(values(s)...)</code> is a greatest lower bound on the nodes appearing in the signature. For example, if <code>s = (predict=yhat, transform=W)</code>, then call <code>fit!(glb(yhat, W))</code>. Here <code>glb</code> is <code>tuple</code> overloaded for nodes.</p><p>See also <a href="#MLJBase.machine"><code>machine</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/composition/learning_networks/machines.jl#LL129-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit!-Tuple{Machine}" href="#StatsBase.fit!-Tuple{Machine}"><code>StatsBase.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(mach::Machine, rows=nothing, verbosity=1, force=false)</code></pre><p>Fit the machine <code>mach</code>. In the case that <code>mach</code> has <code>Node</code> arguments, first train all other machines on which <code>mach</code> depends. </p><p>To attempt to fit a machine without touching any other machine, use <code>fit_only!</code>. For more on the internal logic of fitting see <a href="#MLJBase.fit_only!-Tuple{Machine}"><code>fit_only!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL446-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{Machine{#s38} where #s38&lt;:Union{DeterministicSurrogate, IntervalSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate},Vararg{Pair,N} where N}" href="#Base.replace-Tuple{Machine{#s38} where #s38&lt;:Union{DeterministicSurrogate, IntervalSurrogate, ProbabilisticSurrogate, StaticSurrogate, UnsupervisedSurrogate},Vararg{Pair,N} where N}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace(mach, a1=&gt;b1, a2=&gt;b2, ...; empty_unspecified_sources=false)</code></pre><p>Create a deep copy of a learning network machine <code>mach</code> but replacing any specified sources and models <code>a1, a2, ...</code> of the original underlying network with <code>b1, b2, ...</code>.</p><p>If <code>empty_unspecified_sources=true</code> then any source nodes not specified are replaced with empty source nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/composition/learning_networks/machines.jl#LL175-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.ancestors-Tuple{Machine}" href="#MLJBase.ancestors-Tuple{Machine}"><code>MLJBase.ancestors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ancestors(mach::Machine; self=false)</code></pre><p>All ancestors of <code>mach</code>, including <code>mach</code> if <code>self=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.model_supertype-Tuple{Any}" href="#MLJBase.model_supertype-Tuple{Any}"><code>MLJBase.model_supertype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model_supertype(signature)</code></pre><p>Return, if this can be deduced, which of <code>Deterministic</code>, <code>Probabilistic</code> and <code>Unsupervised</code> is the appropriate supertype for a composite model obtained by exporting a learning network with the specified <code>signature</code>.</p><p>A learning network <em>signature</em> is a named tuple, such as <code>(predict=yhat, transfrom=W)</code>, specifying what nodes of the network are called to produce output of each operation represented by the keys, in an exported version of the network.</p><p>If a supertype cannot be deduced, <code>nothing</code> is returned.</p><p>If the network with given <code>signature</code> is not exportable, this method will not error but it will not a give meaningful return value either.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/composition/learning_networks/machines.jl#LL10-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.save-Tuple{Any,Machine}" href="#MLJModelInterface.save-Tuple{Any,Machine}"><code>MLJModelInterface.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MLJ.save(filename, mach::Machine; kwargs...)
MLJ.save(io, mach::Machine; kwargs...)

MLJBase.save(filename, mach::Machine; kwargs...)
MLJBase.save(io, mach::Machine; kwargs...)</code></pre><p>Serialize the machine <code>mach</code> to a file with path <code>filename</code>, or to an input/output stream <code>io</code> (at least <code>IOBuffer</code> instances are supported).</p><p>The format is JLSO (a wrapper for julia native or BSON serialization) unless a custom format has been implemented for the model type of <code>mach.model</code>. The keyword arguments <code>kwargs</code> are passed to the format-specific serializer, which in the JSLO case include these:</p><table><tr><th style="text-align: right">keyword</th><th style="text-align: right">values</th><th style="text-align: right">default</th></tr><tr><td style="text-align: right"><code>format</code></td><td style="text-align: right"><code>:julia_serialize</code>, <code>:BSON</code></td><td style="text-align: right"><code>:julia_serialize</code></td></tr><tr><td style="text-align: right"><code>compression</code></td><td style="text-align: right"><code>:gzip</code>, <code>:none</code></td><td style="text-align: right"><code>:none</code></td></tr></table><p>See (see <a href="https://github.com/invenia/JLSO.jl">https://github.com/invenia/JLSO.jl</a> for details.</p><p>Machines are de-serialized using the <code>machine</code> constructor as shown in the example below. Data (or nodes) may be optionally passed to the constructor for retraining on new data using the saved model.</p><p><strong>Example</strong></p><pre><code class="language-none">using MLJ
tree = @load DecisionTreeClassifier
X, y = @load_iris
mach = fit!(machine(tree, X, y))

MLJ.save(&quot;tree.jlso&quot;, mach, compression=:none)
mach_predict_only = machine(&quot;tree.jlso&quot;)
predict(mach_predict_only, X)

mach2 = machine(&quot;tree.jlso&quot;, selectrows(X, 1:100), y[1:100])
predict(mach2, X) # same as above

fit!(mach2) # saved learned parameters are over-written
predict(mach2, X) # not same as above

# using a buffer:
io = IOBuffer()
MLJ.save(io, mach)
seekstart(io)
predict_only_mach = machine(io)
predict(predict_only_mach, X)</code></pre><div class="admonition is-warning"><header class="admonition-header">Only load files from trusted sources</header><div class="admonition-body"><p>Maliciously constructed JLSO files, like pickles, and most other general purpose serialization formats, can allow for arbitrary code execution during loading. This means it is possible for someone to use a JLSO file that looks like a serialized MLJ machine as a <a href="https://en.wikipedia.org/wiki/Trojan_horse_(computing)">Trojan horse</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/machines.jl#LL583-L645">source</a></section></article><h2 id="Parameter-Inspection-1"><a class="docs-heading-anchor" href="#Parameter-Inspection-1">Parameter Inspection</a><a class="docs-heading-anchor-permalink" href="#Parameter-Inspection-1" title="Permalink"></a></h2><h2 id="Show-1"><a class="docs-heading-anchor" href="#Show-1">Show</a><a class="docs-heading-anchor-permalink" href="#Show-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.color_off-Tuple{}" href="#MLJBase.color_off-Tuple{}"><code>MLJBase.color_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">color_off()</code></pre><p>Suppress color and bold output at the REPL for displaying MLJ objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.color_on-Tuple{}" href="#MLJBase.color_on-Tuple{}"><code>MLJBase.color_on</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">color_on()</code></pre><p>Enable color and bold output at the REPL, for enhanced display of MLJ objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@constant-Tuple{Any}" href="#MLJBase.@constant-Tuple{Any}"><code>MLJBase.@constant</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@constant x = value</code></pre><p>Equivalent to <code>const x = value</code> but registers the binding thus:</p><pre><code class="language-none">MLJBase.HANDLE_GIVEN_ID[objectid(value)] = :x</code></pre><p>Registered objects get displayed using the variable name to which it was bound in calls to <code>show(x)</code>, etc.</p><p>WARNING: As with any <code>const</code> declaration, binding <code>x</code> to new value of the same type is not prevented and the registration will not be updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL25-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.@more-Tuple{}" href="#MLJBase.@more-Tuple{}"><code>MLJBase.@more</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@more</code></pre><p>Entered at the REPL, equivalent to <code>show(ans, 100)</code>. Use to get a recursive description of all fields of the last REPL value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase._recursive_show-Tuple{IO,MLJType,Any,Any}" href="#MLJBase._recursive_show-Tuple{IO,MLJType,Any,Any}"><code>MLJBase._recursive_show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_recursive_show(stream, object, current_depth, depth)</code></pre><p>Generate a table of the field values of the <code>MLJType</code> object, dislaying each value by calling the method <code>_show</code> on it. The behaviour of <code>_show(stream, f)</code> is as follows:</p><ol><li>If <code>f</code> is itself a <code>MLJType</code> object, then its short form is shown</li></ol><p>and <code>_recursive_show</code> generates as separate table for each of its field values (and so on, up to a depth of argument <code>depth</code>).</p><ol><li>Otherwise <code>f</code> is displayed as &quot;(omitted T)&quot; where <code>T = typeof(f)</code>,</li></ol><p>unless <code>istoobig(f)</code> is false (the <code>istoobig</code> fall-back for arbitrary types being <code>true</code>). In the latter case, the long (ie, MIME&quot;plain/text&quot;) form of <code>f</code> is shown. To override this behaviour, overload the <code>_show</code> method for the type in question.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL308-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.abbreviated-Tuple{Any}" href="#MLJBase.abbreviated-Tuple{Any}"><code>MLJBase.abbreviated</code></a> — <span class="docstring-category">Method</span></header><section><div><p>to display abbreviated versions of integers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.handle-Tuple{Any}" href="#MLJBase.handle-Tuple{Any}"><code>MLJBase.handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>return abbreviated object id (as string) or it&#39;s registered handle (as string) if this exists</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/show.jl#LL68-L70">source</a></section></article><h2 id="Utility-functions-1"><a class="docs-heading-anchor" href="#Utility-functions-1">Utility functions</a><a class="docs-heading-anchor-permalink" href="#Utility-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.flat_values-Tuple{NamedTuple}" href="#MLJBase.flat_values-Tuple{NamedTuple}"><code>MLJBase.flat_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flat_values(t::NamedTuple)</code></pre><p>View a nested named tuple <code>t</code> as a tree and return, as a tuple, the values at the leaves, in the order they appear in the original tuple.</p><pre><code class="language-julia-repl">julia&gt; t = (X = (x = 1, y = 2), Y = 3)
julia&gt; flat_values(t)
(1, 2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.recursive_getproperty-Tuple{Any,Symbol}" href="#MLJBase.recursive_getproperty-Tuple{Any,Symbol}"><code>MLJBase.recursive_getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recursive_getproperty(object, nested_name::Expr)</code></pre><p>Call getproperty recursively on <code>object</code> to extract the value of some nested property, as in the following example:</p><pre><code class="language-none">julia&gt; object = (X = (x = 1, y = 2), Y = 3)
julia&gt; recursive_getproperty(object, :(X.y))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.recursive_setproperty!-Tuple{Any,Symbol,Any}" href="#MLJBase.recursive_setproperty!-Tuple{Any,Symbol,Any}"><code>MLJBase.recursive_setproperty!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recursively_setproperty!(object, nested_name::Expr, value)</code></pre><p>Set a nested property of an <code>object</code> to <code>value</code>, as in the following example:</p><pre><code class="language-none">julia&gt; mutable struct Foo
           X
           Y
       end

julia&gt; mutable struct Bar
           x
           y
       end

julia&gt; object = Foo(Bar(1, 2), 3)
Foo(Bar(1, 2), 3)

julia&gt; recursively_setproperty!(object, :(X.y), 42)
42

julia&gt; object
Foo(Bar(1, 42), 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL137-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.unwind-Tuple" href="#MLJBase.unwind-Tuple"><code>MLJBase.unwind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwind(iterators...)</code></pre><p>Represent all possible combinations of values generated by <code>iterators</code> as rows of a matrix <code>A</code>. In more detail, <code>A</code> has one column for each iterator in <code>iterators</code> and one row for each distinct possible combination of values taken on by the iterators. Elements in the first column cycle fastest, those in the last clolumn slowest.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; iterators = ([1, 2], [&quot;a&quot;,&quot;b&quot;], [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);
julia&gt; MLJTuning.unwind(iterators...)
12×3 Array{Any,2}:
 1  &quot;a&quot;  &quot;x&quot;
 2  &quot;a&quot;  &quot;x&quot;
 1  &quot;b&quot;  &quot;x&quot;
 2  &quot;b&quot;  &quot;x&quot;
 1  &quot;a&quot;  &quot;y&quot;
 2  &quot;a&quot;  &quot;y&quot;
 1  &quot;b&quot;  &quot;y&quot;
 2  &quot;b&quot;  &quot;y&quot;
 1  &quot;a&quot;  &quot;z&quot;
 2  &quot;a&quot;  &quot;z&quot;
 1  &quot;b&quot;  &quot;z&quot;
 2  &quot;b&quot;  &quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL248-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase._permute_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Array{Int64,1}}" href="#MLJBase._permute_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Array{Int64,1}}"><code>MLJBase._permute_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>permute</em>rows(obj, perm)</p><p>Internal function to return a vector or matrix with permuted rows given the permutation <code>perm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.available_name-Tuple{Any,Any}" href="#MLJBase.available_name-Tuple{Any,Any}"><code>MLJBase.available_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">available_name(modl::Module, name::Symbol)</code></pre><p>Function to replace, if necessary, a given <code>name</code> with a modified one that ensures it is not the name of any existing object in the global scope of <code>modl</code>. Modifications are created with numerical suffixes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL340-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.check_dimensions-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#MLJBase.check_dimensions-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>MLJBase.check_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_dimension(X, Y)</code></pre><p>Check that two vectors or matrices have matching dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.chunks-Tuple{AbstractRange,Integer}" href="#MLJBase.chunks-Tuple{AbstractRange,Integer}"><code>MLJBase.chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chunks(range, n)</code></pre><p>split a given range into <code>n</code> subranges of approximately equal length.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; collect(chunks(1:5, 2))
2-element Array{UnitRange{Int64},1}:
 1:3
 4:5
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL300-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.shuffle_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#MLJBase.shuffle_rows-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>MLJBase.shuffle_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><p>shuffle_rows(X, Y, ...; rng=)</p><p>Return a shuffled view of a vector or  matrix <code>X</code> (or set of such) using a random permutation (which can be seeded specifying <code>rng</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alan-turing-institute/MLJBase.jl/blob/11f1ab1701ed3a6abcc00c742d8a448fe2a30845/src/utilities.jl#LL196-L201">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../openml/">« OpenML</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 26 July 2020 23:21">Sunday 26 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
